<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LinkedIn Knowledge Graph Explorer</title>
    
    <!-- PapaParse for CSV parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    
    <!-- D3.js for graph visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>

    <!-- AnyChart for timeline visualization -->
    <script src="https://cdn.anychart.com/releases/v8/js/anychart-base.min.js"></script>
    <script src="https://cdn.anychart.com/releases/v8/js/anychart-timeline.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
            flex-direction: column;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .header h1 {
            color: #0077b5;
            font-size: 24px;
            font-weight: 600;
        }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .search-box {
            padding: 8px 15px;
            border: 2px solid #ddd;
            border-radius: 20px;
            font-size: 14px;
            width: 250px;
            transition: border-color 0.3s;
        }

        .search-box:focus {
            outline: none;
            border-color: #0077b5;
        }

        .btn {
            padding: 8px 20px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
            background: #0077b5;
            color: white;
        }

        .btn:hover {
            background: #005885;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
        }

        .btn-success:hover {
            background: #218838;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            flex-direction: column;
        }

        /* Main Home Screen */
        .home-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 40px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow-y: auto;
        }

        .home-screen.hidden {
            display: none;
        }

        .home-title {
            color: white;
            font-size: 42px;
            font-weight: 300;
            margin-bottom: 16px;
            text-align: center;
        }

        .home-subtitle {
            color: rgba(255, 255, 255, 0.9);
            font-size: 18px;
            font-weight: 300;
            margin-bottom: 60px;
            text-align: center;
        }

        .viz-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 30px;
            max-width: 1400px;
            width: 100%;
        }

        .viz-card {
            background: white;
            border-radius: 16px;
            padding: 32px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1),
                        0 1px 3px rgba(0, 0, 0, 0.08);
            position: relative;
            overflow: hidden;
        }

        .viz-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transform: scaleX(0);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .viz-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.15),
                        0 6px 12px rgba(0, 0, 0, 0.1);
        }

        .viz-card:hover::before {
            transform: scaleX(1);
        }

        .viz-card-icon {
            font-size: 48px;
            margin-bottom: 16px;
            display: block;
        }

        .viz-card-title {
            font-size: 24px;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
        }

        .viz-card-description {
            font-size: 14px;
            color: #6c757d;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .viz-card-stats {
            display: flex;
            gap: 16px;
            margin-top: auto;
        }

        .viz-card-stat {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            color: #667eea;
            font-weight: 500;
        }

        .back-button {
            position: fixed;
            top: 80px;
            left: 20px;
            background: white;
            border: none;
            padding: 12px 24px;
            border-radius: 24px;
            font-size: 14px;
            font-weight: 600;
            color: #667eea;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transition: all 0.3s;
            z-index: 1000;
            display: none;
        }

        .back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        }

        .back-button.visible {
            display: block;
        }

        .viz-tabs {
            display: none;
        }

        .viz-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .home-title {
                font-size: 32px;
            }

            .home-subtitle {
                font-size: 16px;
                margin-bottom: 40px;
            }

            .home-screen {
                padding: 40px 20px;
            }

            .viz-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .viz-card {
                padding: 24px;
            }

            .viz-card-icon {
                font-size: 40px;
            }

            .viz-card-title {
                font-size: 20px;
            }

            .back-button {
                top: 70px;
                left: 10px;
                padding: 10px 20px;
                font-size: 13px;
            }
        }

        .viz-panel {
            display: none;
            flex: 1;
            position: relative;
        }

        .graph-container {
            flex: 1;
            position: relative;
            background: #1a1a2e;
        }

        .viz-panel.active {
            display: flex;
            flex-direction: column;
            flex: 1;
        }

        #graph, #timelineChart, #bubbleChart {
            width: 100%;
            height: 100%;
        }

        .sidebar {
            width: 350px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            overflow-y: auto;
            box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            display: none;
        }

        .sidebar.active {
            display: block;
        }

        .sidebar h2 {
            color: #0077b5;
            margin-bottom: 15px;
            font-size: 20px;
        }


        .node-info {
            margin-bottom: 20px;
        }

        .info-item {
            margin-bottom: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .info-label {
            font-weight: 600;
            color: #495057;
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .info-value {
            color: #212529;
            font-size: 14px;
            word-break: break-word;
        }


        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            z-index: 2000;
            text-align: center;
        }

        .loading.hidden {
            display: none;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #0077b5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 3000;
            display: none;
        }

        .notification.error {
            background: #dc3545;
        }

        .notification.show {
            display: block;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Modal Dialog for Company Network */
        .modal {
            display: none;
            position: fixed;
            z-index: 4000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            animation: fadeIn 0.3s ease-out;
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: #fff;
            border-radius: 12px;
            width: 90%;
            height: 85%;
            max-width: 1400px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            animation: slideUp 0.3s ease-out;
        }

        .modal-header {
            padding: 20px 30px;
            border-bottom: 2px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px 12px 0 0;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 24px;
        }

        .modal-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            font-size: 28px;
            cursor: pointer;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }

        .modal-body {
            flex: 1;
            padding: 20px;
            overflow: hidden;
            position: relative;
            background: #1a1a2e;
        }

        #companyNetworkGraph {
            width: 100%;
            height: 100%;
            background: #1a1a2e;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }

        /* Calendar Day Connection Cards */
        .connection-card {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            transition: all 0.2s;
            cursor: pointer;
        }

        .connection-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-2px);
            border-color: #0077b5;
        }

        .connection-card-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 10px;
        }

        .connection-card-name {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .connection-card-company {
            font-size: 14px;
            color: #0077b5;
            font-weight: 500;
        }

        .connection-card-position {
            font-size: 13px;
            color: #6c757d;
            margin-top: 5px;
        }

        .connection-card-badge {
            background: #0077b5;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }

        .connection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîó LinkedIn Knowledge Graph Explorer</h1>
            <div class="controls">
                <input type="text" id="searchBox" class="search-box" placeholder="üîç Search connections..." oninput="handleSearch()">
                <button class="btn btn-secondary" onclick="resetView()">üîÑ Reset View</button>
                <button class="btn btn-success" onclick="exportGraph()">üíæ Export Graph</button>
            </div>
        </div>

        <button class="back-button" id="backButton" onclick="goHome()">‚Üê Back to Home</button>

        <div class="main-content">
            <!-- Home Screen -->
            <div class="home-screen" id="homeScreen">
                <h1 class="home-title">LinkedIn Knowledge Graph Explorer</h1>
                <p class="home-subtitle">Visualize and explore your professional network</p>

                <div class="viz-grid">
                    <div class="viz-card" onclick="switchViz('graph')">
                        <span class="viz-card-icon">üîó</span>
                        <h3 class="viz-card-title">Network Graph</h3>
                        <p class="viz-card-description">Interactive force-directed graph showing your connections grouped by companies and professions. Explore relationships and discover patterns.</p>
                        <div class="viz-card-stats">
                            <span class="viz-card-stat">üìä Dynamic Layout</span>
                            <span class="viz-card-stat">üéØ Group by Profession</span>
                        </div>
                    </div>

                    <div class="viz-card" onclick="switchViz('timeline')">
                        <span class="viz-card-icon">üìà</span>
                        <h3 class="viz-card-title">Timeline Chart</h3>
                        <p class="viz-card-description">Track when you made connections over time. Visualize your networking activity and growth trends across years.</p>
                        <div class="viz-card-stats">
                            <span class="viz-card-stat">üìÖ Year by Year</span>
                            <span class="viz-card-stat">üìä Bar Chart</span>
                        </div>
                    </div>

                    <div class="viz-card" onclick="switchViz('bubble')">
                        <span class="viz-card-icon">‚ö™</span>
                        <h3 class="viz-card-title">Bubble Chart</h3>
                        <p class="viz-card-description">Company-based visualization where bubble size represents the number of connections at each organization.</p>
                        <div class="viz-card-stats">
                            <span class="viz-card-stat">üè¢ By Company</span>
                            <span class="viz-card-stat">üìè Size = Connections</span>
                        </div>
                    </div>

                    <div class="viz-card" onclick="switchViz('calendar')">
                        <span class="viz-card-icon">üìÖ</span>
                        <h3 class="viz-card-title">Calendar Heatmap</h3>
                        <p class="viz-card-description">GitHub-style calendar showing your connection activity. Identify your most active networking periods.</p>
                        <div class="viz-card-stats">
                            <span class="viz-card-stat">üóìÔ∏è Daily View</span>
                            <span class="viz-card-stat">üî• Activity Heatmap</span>
                        </div>
                    </div>

                    <div class="viz-card" onclick="switchViz('career')">
                        <span class="viz-card-icon">üíº</span>
                        <h3 class="viz-card-title">Career Timeline</h3>
                        <p class="viz-card-description">Visualize your professional journey with positions timeline. See connection growth during each role.</p>
                        <div class="viz-card-stats">
                            <span class="viz-card-stat">üéØ Positions</span>
                            <span class="viz-card-stat">üìä Connections per Role</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="viz-content">
                <div class="viz-panel" id="graphPanel">
                    <!-- Panel Header for CSV Loading -->
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid rgba(255,255,255,0.1);">
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <h3 style="margin: 0; color: white; font-size: 18px; font-weight: 600;">üîó Network Graph</h3>
                            <span id="connectionCount" style="background: rgba(255, 255, 255, 0.2); padding: 6px 12px; border-radius: 15px; font-weight: 600; color: white; font-size: 13px; display: none;">0 connections</span>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <input type="file" id="csvFile" accept=".csv" style="display: none;">
                            <button class="btn" onclick="loadCSV()" style="background: white; color: #667eea; font-weight: 600;">üìÅ Load CSV</button>
                            <button class="btn btn-secondary" onclick="downloadSampleConnections()" style="font-size: 13px; background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3);">‚¨áÔ∏è Sample CSV</button>
                        </div>
                    </div>

                    <div class="graph-container">
                        <!-- Year Navigation Controls -->
                        <div id="graphControls" style="text-align: center; padding: 15px 20px; border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <button class="btn" onclick="changeGraphYear(-1)">‚Üê Previous Year</button>
                            <span id="graphYear" style="font-size: 20px; font-weight: bold; margin: 0 20px; color: white;">All Years</span>
                            <button class="btn" onclick="changeGraphYear(1)">Next Year ‚Üí</button>
                            <button class="btn btn-secondary" onclick="resetGraphYear()" style="margin-left: 20px;">Show All Years</button>
                        </div>
                        <div style="text-align: center; padding: 10px 20px; display: flex; justify-content: center; align-items: center; gap: 20px;">
                            <div>
                                <label for="minCompanySizeSelect" style="color: white; font-size: 13px; margin-right: 8px;">
                                    Min connections per company:
                                </label>
                                <select id="minCompanySizeSelect" onchange="updateMinCompanySize(this.value)"
                                        style="padding: 5px 10px; border-radius: 5px; border: 1px solid #ddd; font-size: 13px; cursor: pointer;">
                                    <option value="1">1+</option>
                                    <option value="2">2+</option>
                                    <option value="3">3+</option>
                                    <option value="5" selected>5+</option>
                                    <option value="10">10+</option>
                                    <option value="15">15+</option>
                                    <option value="20">20+</option>
                                    <option value="30">30+</option>
                                    <option value="50">50+</option>
                                </select>
                            </div>
                            <div>
                                <label style="color: white; font-size: 13px; cursor: pointer; display: flex; align-items: center; gap: 5px;">
                                    <input type="checkbox" id="showMembersCheckbox" onchange="toggleShowMembers(this.checked)" checked
                                           style="cursor: pointer; width: 16px; height: 16px;">
                                    Show individual connections
                                </label>
                            </div>
                            <div>
                                <label style="color: white; font-size: 13px; cursor: pointer; display: flex; align-items: center; gap: 5px;">
                                    <input type="checkbox" id="groupByProfessionCheckbox" onchange="toggleGroupByProfession(this.checked)"
                                           style="cursor: pointer; width: 16px; height: 16px;">
                                    Group by profession
                                </label>
                            </div>
                        </div>
                        <svg id="graph"></svg>
                        <div class="tooltip" id="tooltip"></div>
                    </div>
                </div>
                <div class="viz-panel" id="timelinePanel">
                    <!-- Panel Header -->
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid rgba(255,255,255,0.1);">
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <h3 style="margin: 0; color: white; font-size: 18px; font-weight: 600;">üìà Timeline Chart</h3>
                            <span id="timelineConnectionCount" style="background: rgba(255, 255, 255, 0.2); padding: 6px 12px; border-radius: 15px; font-weight: 600; color: white; font-size: 13px; display: none;">0 connections</span>
                        </div>
                    </div>

                    <div class="graph-container">
                        <div id="timelineControls" style="text-align: center; padding: 15px 20px; border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <button class="btn" onclick="changeTimelineYear(-1)">‚Üê Previous Year</button>
                            <span id="timelineYear" style="font-size: 20px; font-weight: bold; margin: 0 20px; color: white;">All Years</span>
                            <button class="btn" onclick="changeTimelineYear(1)">Next Year ‚Üí</button>
                            <button class="btn btn-secondary" onclick="resetTimelineYear()" style="margin-left: 20px;">Show All Years</button>
                        </div>
                        <svg id="timelineChart"></svg>
                    </div>
                </div>
                <div class="viz-panel" id="bubblePanel">
                    <!-- Panel Header -->
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid rgba(255,255,255,0.1);">
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <h3 style="margin: 0; color: white; font-size: 18px; font-weight: 600;">‚ö™ Bubble Chart</h3>
                            <span id="bubbleConnectionCount" style="background: rgba(255, 255, 255, 0.2); padding: 6px 12px; border-radius: 15px; font-weight: 600; color: white; font-size: 13px; display: none;">0 connections</span>
                        </div>
                    </div>

                    <div class="graph-container">
                        <div id="bubbleControls" style="text-align: center; padding: 15px 20px; border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <button class="btn" onclick="changeBubbleYear(-1)">‚Üê Previous Year</button>
                            <span id="bubbleYear" style="font-size: 20px; font-weight: bold; margin: 0 20px; color: white;">All Years</span>
                            <button class="btn" onclick="changeBubbleYear(1)">Next Year ‚Üí</button>
                            <button class="btn btn-secondary" onclick="resetBubbleYear()" style="margin-left: 20px;">Show All Years</button>
                        </div>
                        <svg id="bubbleChart"></svg>
                    </div>
                </div>
                <div class="viz-panel" id="calendarPanel">
                    <!-- Panel Header -->
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid rgba(255,255,255,0.1);">
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <h3 style="margin: 0; color: white; font-size: 18px; font-weight: 600;">üìÖ Calendar Heatmap</h3>
                            <span id="calendarConnectionCount" style="background: rgba(255, 255, 255, 0.2); padding: 6px 12px; border-radius: 15px; font-weight: 600; color: white; font-size: 13px; display: none;">0 connections</span>
                        </div>
                    </div>

                    <div class="graph-container">
                        <div id="calendarControls" style="text-align: center; padding: 15px 20px; border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <button class="btn" onclick="changeCalendarYear(-1)">‚Üê Previous Year</button>
                            <span id="calendarYear" style="font-size: 20px; font-weight: bold; margin: 0 20px; color: white;">2024</span>
                            <button class="btn" onclick="changeCalendarYear(1)">Next Year ‚Üí</button>
                        </div>
                        <svg id="calendarChart"></svg>
                    </div>
                </div>
                <div class="viz-panel" id="careerPanel">
                    <!-- Panel Header -->
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid rgba(255,255,255,0.1);">
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <h3 style="margin: 0; color: white; font-size: 18px; font-weight: 600;">üíº Career Timeline</h3>
                            <span id="careerConnectionCount" style="background: rgba(255, 255, 255, 0.2); padding: 6px 12px; border-radius: 15px; font-weight: 600; color: white; font-size: 13px; display: none;">0 connections</span>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <input type="file" id="careerCsvFile" accept=".csv" style="display: none;">
                            <button class="btn" onclick="loadCareerCSV()" style="background: white; color: #667eea; font-weight: 600;">üìÅ Load Career CSV</button>
                            <button class="btn btn-secondary" onclick="downloadSamplePositions()" style="font-size: 13px; background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3);">‚¨áÔ∏è Sample Positions CSV</button>
                        </div>
                    </div>

                    <div class="graph-container">
                        <div id="careerTimeline" style="width: 100%; height: calc(100vh - 250px);"></div>
                    </div>
                </div>
                <div class="sidebar" id="sidebar">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h2 style="margin: 0;">Connection Details</h2>
                    <button onclick="closeSidebar()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #6c757d; padding: 0; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; border-radius: 4px; transition: all 0.2s;" onmouseover="this.style.background='#f0f0f0'; this.style.color='#333';" onmouseout="this.style.background='none'; this.style.color='#6c757d';">&times;</button>
                </div>
                <div id="nodeInfo">
                    <p style="color: #6c757d; font-size: 14px;">Click on a node to view details</p>
                </div>
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <div id="loadingText">Click "Load CSV" to import your LinkedIn connections</div>
        </div>

        <div class="notification" id="notification"></div>

        <!-- Modal for Calendar Day Connections -->
        <div id="calendarDayModal" class="modal">
            <div class="modal-content" style="max-width: 900px; height: 70%;">
                <div class="modal-header">
                    <h2 id="calendarDayTitle">Connections</h2>
                    <button class="modal-close" onclick="closeCalendarDayModal()">&times;</button>
                </div>
                <div class="modal-body" style="padding: 30px; overflow-y: auto; background: #f8f9fa;">
                    <div id="calendarDayConnections"></div>
                </div>
            </div>
        </div>

        <!-- Modal for Company Network Graph -->
        <div id="companyModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 id="modalCompanyName">Company Network</h2>
                    <button class="modal-close" onclick="closeCompanyModal()">&times;</button>
                </div>
                <div class="modal-body" style="display: flex; gap: 20px;">
                    <div id="companyNetworkGraph" style="flex: 1;"></div>
                    <div id="modalSidebar" style="width: 320px; background: rgba(255, 255, 255, 0.95); border-radius: 8px; padding: 20px; overflow-y: auto; box-shadow: -2px 0 10px rgba(0,0,0,0.3);">
                        <h3 style="margin: 0 0 15px 0; color: #0077b5; font-size: 18px; font-weight: 600;">Connection Details</h3>
                        <div id="modalNodeInfo">
                            <p style="color: #6c757d; font-size: 14px; text-align: center; padding: 40px 20px;">Click on a profession to see members or a person to view details</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let allData = [];
        let filteredData = [];
        let simulation;
        let svg, g, link, node, text;
        let selectedNode = null;
        let isLoading = false;
        let selectedCompanies = new Set();
        let companyColors = {};
        let clusteringEnabled = false;
        let currentViz = 'graph';
        const currentYear = new Date().getFullYear();
        let currentCalendarYear = currentYear;
        let currentTimelineYear = currentYear; // Default to current year for faster loading
        let currentGraphYear = currentYear; // Default to current year for faster loading
        let currentBubbleYear = currentYear; // Default to current year for faster loading
        let minCompanySize = 5; // Minimum number of connections per company to display
        let showMembers = true; // Show individual connections (default: true)
        let groupByProfession = false; // Group connections by profession within companies
        let expandedCompanies = new Set(); // Track which companies are expanded when showMembers is false
        let hoverTimeout = null; // Timeout for delayed hover effect
        let hoveredCompany = null; // Currently hovered company
        
        // Initialize
        document.getElementById('csvFile').addEventListener('change', handleFileSelect);
        
        function switchViz(vizType) {
            currentViz = vizType;

            // Hide home screen and show back button
            document.getElementById('homeScreen').classList.add('hidden');
            document.getElementById('backButton').classList.add('visible');

            // Update panels
            document.querySelectorAll('.viz-panel').forEach(panel => panel.classList.remove('active'));

            if (vizType === 'graph') {
                document.getElementById('graphPanel').classList.add('active');
                applyYearFilterAndRebuild();
            } else if (vizType === 'timeline') {
                document.getElementById('timelinePanel').classList.add('active');
                buildTimelineChart(filteredData, currentTimelineYear);
            } else if (vizType === 'bubble') {
                document.getElementById('bubblePanel').classList.add('active');
                buildBubbleChart(filteredData, currentBubbleYear);
            } else if (vizType === 'calendar') {
                document.getElementById('calendarPanel').classList.add('active');
                buildCalendarChart(filteredData, currentCalendarYear);
            } else if (vizType === 'career') {
                document.getElementById('careerPanel').classList.add('active');
                // Career timeline is loaded separately with its own CSV
            }
        }

        function goHome() {
            // Show home screen and hide back button
            document.getElementById('homeScreen').classList.remove('hidden');
            document.getElementById('backButton').classList.remove('visible');

            // Hide all panels
            document.querySelectorAll('.viz-panel').forEach(panel => panel.classList.remove('active'));

            // Close sidebar if open
            document.getElementById('sidebar').classList.remove('active');

            currentViz = 'home';
        }
        
        function toggleClustering(enabled) {
            clusteringEnabled = enabled;
            console.log('Clustering toggled:', enabled);

            // Rebuild graph with clustering
            if (filteredData.length > 0) {
                applyYearFilterAndRebuild();
            }
            
            if (enabled) {
                showNotification('Company clustering enabled! Nodes grouped by company.', 'success');
            } else {
                showNotification('Company clustering disabled.', 'success');
            }
        }
        
        function buildCompanyFilter() {
            // Generate colors for each company
            const companyCounts = {};
            allData.forEach(conn => {
                const company = conn.company || 'Unknown';
                companyCounts[company] = (companyCounts[company] || 0) + 1;
            });

            const sortedCompanies = Object.entries(companyCounts)
                .sort((a, b) => b[1] - a[1]);

            const colors = [
                '#0077b5', '#28a745', '#dc3545', '#ffc107', '#17a2b8',
                '#6f42c1', '#fd7e14', '#20c997', '#e83e8c', '#6c757d',
                '#007bff', '#28a745', '#ffc107', '#dc3545', '#17a2b8'
            ];

            sortedCompanies.forEach(([company], index) => {
                companyColors[company] = colors[index % colors.length];
                selectedCompanies.add(company); // All selected by default
            });
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function toggleCompany(company) {
            const checkbox = document.getElementById(`company_${company}`);
            if (checkbox) {
                checkbox.checked = !checkbox.checked;
                handleCompanyCheckbox(company, checkbox.checked);
            }
        }
        
        function handleCompanyCheckbox(company, eventOrChecked) {
            // Handle both real events and boolean values
            let isChecked;
            if (typeof eventOrChecked === 'boolean') {
                isChecked = eventOrChecked;
            } else {
                if (eventOrChecked.stopPropagation) {
                    eventOrChecked.stopPropagation();
                }
                isChecked = eventOrChecked.target.checked;
            }
            
            if (isChecked) {
                selectedCompanies.add(company);
            } else {
                selectedCompanies.delete(company);
            }
            
            applyCompanyFilter();
        }
        
        
        function applyCompanyFilter() {
            console.log('=== APPLYING COMPANY FILTER ===');
            console.log('Selected companies:', Array.from(selectedCompanies));

            // Filter data based on selected companies
            filteredData = allData.filter(conn => {
                const company = conn.company || 'Unknown';
                return selectedCompanies.has(company);
            });

            console.log(`Filtered to ${filteredData.length} connections`);

            // Rebuild all visualizations with year filters applied
            applyYearFilterAndRebuild();
            buildTimelineChart(filteredData, currentTimelineYear);
            buildBubbleChart(filteredData, currentBubbleYear);

            showNotification(`Showing ${filteredData.length} connections from ${selectedCompanies.size} companies`, 'success');
        }
        
        function loadCSV() {
            document.getElementById('csvFile').click();
        }
        
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                showLoading(true);
                const reader = new FileReader();
                reader.onload = function(e) {
                    parseCSV(e.target.result);
                };
                reader.readAsText(file);
            }
        }
        
        function parseCSV(csvText) {
            Papa.parse(csvText, {
                header: true,
                skipEmptyLines: true,
                dynamicTyping: false,
                transformHeader: function(header) {
                    // Clean up headers - remove BOM and special characters
                    return header.trim().replace(/^\uFEFF/, '');
                },
                complete: function(results) {
                    console.log('Parsed CSV data:', results);
                    console.log('Total rows:', results.data.length);
                    console.log('Headers:', results.meta.fields);
                    console.log('Sample rows:', results.data.slice(0, 3));
                    
                    // Filter out empty rows and map data
                    const filtered = results.data.filter(row => {
                        const firstName = (row['First Name'] || '').trim();
                        return firstName && firstName !== 'Notes:' && firstName.length > 0;
                    });
                    
                    console.log('Filtered rows:', filtered.length);
                    
                    allData = filtered.map((row, index) => {
                        // Clean up special unicode characters from names
                        const firstName = (row['First Name'] || '').trim()
                            .replace(/[\u202a\u202c\u200f\u200e]/g, ''); // Remove direction marks
                        const lastName = (row['Last Name'] || '').trim()
                            .replace(/[\u202a\u202c\u200f\u200e]/g, '');
                        
                        return {
                            id: index,
                            firstName: firstName,
                            lastName: lastName,
                            fullName: `${firstName} ${lastName}`.trim(),
                            company: (row['Company'] || 'Unknown').trim(),
                            position: (row['Position'] || 'Unknown').trim(),
                            email: (row['Email Address'] || '').trim(),
                            url: (row['URL'] || '').trim(),
                            connectedOn: (row['Connected On'] || '').trim()
                        };
                    });
                    
                    console.log('Final data count:', allData.length);
                    console.log('Sample processed data:', allData.slice(0, 3));
                    
                    if (allData.length === 0) {
                        showLoading(false);
                        showNotification('No connections found in CSV. Please check the file format.', 'error');
                        console.error('Available columns:', results.meta.fields);
                        return;
                    }
                    
                    filteredData = [...allData];

                    console.log(`Loaded ${filteredData.length} total connections`);

                    try {
                        // Build company filter list
                        buildCompanyFilter();

                        // Update year display labels
                        document.getElementById('graphYear').textContent = currentGraphYear;
                        document.getElementById('timelineYear').textContent = currentTimelineYear;
                        document.getElementById('bubbleYear').textContent = currentBubbleYear;

                        // Build all visualizations with current year by default
                        applyYearFilterAndRebuild();
                        buildTimelineChart(filteredData, currentTimelineYear);
                        buildBubbleChart(filteredData, currentBubbleYear);

                        showNotification(`Loaded ${allData.length} connections. Showing ${currentYear} by default.`, 'success');
                        updateStats();
                    } catch (error) {
                        console.error('Error building visualizations:', error);
                        showNotification('Error building visualizations: ' + error.message, 'error');
                    } finally {
                        // Always hide loading indicator
                        showLoading(false);
                    }
                },
                error: function(error) {
                    showLoading(false);
                    showNotification('Error parsing CSV: ' + error.message, 'error');
                    console.error('Parse error:', error);
                }
            });
        }
        
        function buildGraph(data) {
            console.log(`=== BUILD GRAPH CALLED ===`);
            console.log(`Building force-directed tree with ${data.length} connections`);
            
            const width = document.getElementById('graph').clientWidth;
            const height = document.getElementById('graph').clientHeight;
            
            // Clear existing graph
            d3.select('#graph').selectAll('*').remove();
            
            // Setup SVG
            svg = d3.select('#graph')
                .attr('width', width)
                .attr('height', height);
            
            // Add zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });
            
            svg.call(zoom);
            
            g = svg.append('g');
            
            // Build force-directed tree
            buildForceDirectedTree(data, width, height);
        }
        
        function buildForceDirectedTree(data, width, height) {
            // Group connections by company
            const companiesMap = new Map();
            data.forEach(d => {
                const company = d.company || 'Unknown';
                if (!companiesMap.has(company)) {
                    companiesMap.set(company, []);
                }
                companiesMap.get(company).push(d);
            });

            // Create hierarchical structure: You -> Companies -> Professions (optional) -> People
            const root = {
                id: 'central',
                name: 'You',
                type: 'central',
                children: Array.from(companiesMap.entries()).map(([companyName, employees]) => {
                    // Show members if: global showMembers is true OR this specific company is expanded
                    const shouldShowMembers = showMembers || expandedCompanies.has(companyName);

                    let children = [];

                    if (groupByProfession) {
                        // Always show professions when grouping is enabled
                        // Group employees by profession
                        const professionMap = new Map();
                        employees.forEach(emp => {
                            const profession = emp.position || 'Unknown Position';
                            if (!professionMap.has(profession)) {
                                professionMap.set(profession, []);
                            }
                            professionMap.get(profession).push(emp);
                        });

                        // Create profession nodes with optional people as children
                        children = Array.from(professionMap.entries()).map(([professionName, people]) => ({
                            id: `profession_${companyName}_${professionName}`,
                            name: professionName,
                            type: 'profession',
                            company: companyName,
                            employeeCount: people.length,
                            // Only show people if shouldShowMembers is true
                            children: shouldShowMembers ? people.map(d => ({
                                id: d.id,
                                name: d.fullName,
                                type: 'person',
                                data: d,
                                company: companyName,
                                profession: professionName
                            })) : []
                        }));
                    } else if (shouldShowMembers) {
                        // Direct children without profession grouping (only when shouldShowMembers)
                        children = employees.map(d => ({
                            id: d.id,
                            name: d.fullName,
                            type: 'person',
                            data: d,
                            company: companyName
                        }));
                    }

                    return {
                        id: `company_${companyName}`,
                        name: companyName,
                        type: 'company',
                        company: companyName,
                        employeeCount: employees.length,
                        isExpanded: expandedCompanies.has(companyName),
                        children: children
                    };
                })
            };

            // Convert to hierarchy
            const hierarchy = d3.hierarchy(root);
            const links = hierarchy.links();
            const nodes = hierarchy.descendants();

            // Calculate radius scale for company nodes based on employee count
            const companySizes = nodes.filter(d => d.depth === 1).map(d => {
                // Use employeeCount when members are hidden, otherwise use children length
                return showMembers ? (d.children ? d.children.length : 0) : (d.data.employeeCount || 0);
            });
            const maxCompanySize = Math.max(...companySizes);
            const minCompanySizeValue = Math.min(...companySizes);

            // Scale for company node radius (10 to 30 based on employee count)
            const radiusScale = d3.scaleLinear()
                .domain([minCompanySizeValue, maxCompanySize])
                .range([10, 30]);

            // Create force simulation for tree layout with up to 4 levels (with profession grouping)
            simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links)
                    .id(d => d.id)
                    .distance(d => {
                        // Adjust distances based on depth and grouping mode
                        if (d.source.depth === 0) return 200;  // You -> Company
                        if (d.source.depth === 1) return groupByProfession ? 180 : 80;  // Company -> Profession
                        if (d.source.depth === 2 && d.source.data.type === 'profession') return 100;  // Profession -> Person
                        return 80;  // Company -> Person (without profession grouping)
                    })
                    .strength(d => {
                        // Stronger links for higher levels
                        if (d.source.depth === 0) return 0.7;  // You -> Company
                        if (d.source.depth === 1) return groupByProfession ? 0.6 : 0.5;  // Company -> Profession or Person
                        if (d.source.depth === 2 && d.source.data.type === 'profession') return 0.5;  // Profession -> Person
                        return 0.3;
                    }))
                .force('charge', d3.forceManyBody().strength(d => {
                    // Stronger repulsion for profession grouping to prevent overlapping
                    if (d.depth === 0) return -2000;  // You - very strong repulsion
                    if (d.depth === 1) return groupByProfession ? -1500 : -1000;   // Companies - stronger when grouping
                    if (d.depth === 2 && d.data.type === 'profession') return -600;  // Professions - strong repulsion
                    return groupByProfession ? -150 : -100;  // People - stronger when grouped
                }))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => {
                    // Dynamic collision radius based on node size with more spacing
                    if (d.depth === 0) return 35;
                    if (d.depth === 1) {
                        const employeeCount = showMembers ? (d.children ? d.children.length : 0) : (d.data.employeeCount || 0);
                        return radiusScale(employeeCount) + (groupByProfession ? 25 : 15);
                    }
                    if (d.depth === 2 && d.data.type === 'profession') return 25;  // Profession nodes - more space
                    return groupByProfession ? 18 : 15;  // Person nodes - more space when grouped
                }).strength(1.2))
                .force('radial', d3.forceRadial(d => {
                    // Stronger radial positioning for clear layers
                    if (d.depth === 0) return 0;  // You at center
                    if (d.depth === 1) return groupByProfession ? 300 : 280;  // Companies - further when grouping
                    if (d.depth === 2 && d.data.type === 'profession') return 500;  // Professions in middle layer
                    if (groupByProfession && d.depth === 3) return 680;  // People outermost layer when grouped
                    return 450;  // People (without profession grouping)
                }, width / 2, height / 2).strength(groupByProfession ? 0.8 : 0.5));
            
            // Create links
            link = g.append('g')
                .selectAll('line')
                .data(links)
                .join('line')
                .attr('stroke', '#999')
                .attr('stroke-opacity', 0.4)
                .attr('stroke-width', 1.5);
            
            // Create nodes with different sizes for each level
            node = g.append('g')
                .selectAll('circle')
                .data(nodes)
                .join('circle')
                .attr('r', d => {
                    if (d.depth === 0) return 25;      // You (center) - largest
                    if (d.depth === 1) {
                        // Company nodes - size based on employee count
                        const employeeCount = showMembers ? (d.children ? d.children.length : 0) : (d.data.employeeCount || 0);
                        return radiusScale(employeeCount);
                    }
                    if (d.depth === 2 && d.data.type === 'profession') return 12;  // Profession nodes - medium
                    return 6;                           // Person nodes - smallest
                })
                .attr('fill', d => {
                    if (d.depth === 0) return '#0077b5';  // You - LinkedIn blue
                    if (d.depth === 1) {
                        // Company nodes - use company color
                        const company = d.data.company || 'Unknown';
                        return companyColors[company] || '#28a745';
                    }
                    if (d.depth === 2 && d.data.type === 'profession') {
                        // Profession nodes - medium shade of company color
                        const company = d.data?.company || 'Unknown';
                        const color = companyColors[company] || '#28a745';
                        return d3.color(color).brighter(0.2);
                    }
                    // Person nodes - lightest version of company color
                    const company = d.data?.company || 'Unknown';
                    const color = companyColors[company] || '#28a745';
                    return d3.color(color).brighter(0.5);
                })
                .attr('stroke', d => {
                    if (d.depth === 0) return '#fff';
                    if (d.depth === 1) {
                        // Show expanded companies with gold border when members are hidden
                        return (!showMembers && d.data.isExpanded) ? '#ffc107' : '#fff';
                    }
                    if (d.depth === 2 && d.data.type === 'profession') return '#fff';
                    return '#ddd';
                })
                .attr('stroke-width', d => {
                    if (d.depth === 1) {
                        // Thicker border for expanded companies
                        return (!showMembers && d.data.isExpanded) ? 5 : 3;
                    }
                    return 2;
                })
                .attr('opacity', d => d.depth === 2 ? 0.8 : 1)
                .style('cursor', 'pointer')
                .call(drag(simulation))
                .on('click', (event, d) => {
                    event.stopPropagation();  // Prevent event bubbling

                    if (d.depth === 1) {
                        // Company node clicked
                        if (!showMembers) {
                            // If members are globally hidden, toggle expansion for this company
                            const companyName = d.data.company;
                            if (expandedCompanies.has(companyName)) {
                                expandedCompanies.delete(companyName);
                                showNotification(`Collapsed ${companyName}`, 'success');
                            } else {
                                expandedCompanies.add(companyName);
                                showNotification(`Expanded ${companyName} - showing ${d.data.employeeCount} connections`, 'success');
                            }
                            applyYearFilterAndRebuild();
                        } else {
                            // If members are shown, show member list and highlight
                            handleNodeClick({
                                type: 'company',
                                name: d.data.name,
                                data: d.data,
                                children: d.children,
                                depth: d.depth
                            });
                            handleCompanyHighlight(d);
                        }
                    } else if (d.depth === 2 && d.data.type === 'profession') {
                        // Profession node clicked
                        if (!showMembers && d.children && d.children.length === 0) {
                            // If members are hidden, expand this profession to show its people
                            const companyName = d.data.company;
                            expandedCompanies.add(companyName);
                            showNotification(`Expanding ${d.data.name} (${d.data.employeeCount} connections)`, 'success');
                            applyYearFilterAndRebuild();
                        } else {
                            // Show profession member list in sidebar
                            handleNodeClick({
                                type: 'profession',
                                name: d.data.name,
                                data: d.data,
                                children: d.children,
                                parent: d.parent,
                                depth: d.depth
                            });
                        }
                    } else if (d.depth === 2 || d.depth === 3) {
                        // Person node clicked (depth 2 when no profession grouping, depth 3 when grouped)
                        handleNodeClick({
                            id: d.data.id,
                            name: d.data.name,
                            type: d.data.type,
                            data: d.data.data
                        });
                    } else if (d.depth === 0) {
                        // "You" node clicked - reset highlight
                        resetHighlight();
                    }
                })
                .on('mouseover', (event, d) => {
                    const tooltipData = {
                        name: d.data.name
                    };
                    if (d.depth === 1) {
                        // Show company name and count (use employeeCount when members are hidden)
                        const count = showMembers ? (d.children ? d.children.length : 0) : (d.data.employeeCount || 0);
                        tooltipData.name = `${d.data.name} (${count} connections)`;

                        // Set up delayed hover effect for company nodes
                        const companyName = d.data.company;
                        hoveredCompany = companyName;

                        // Clear any existing timeout
                        if (hoverTimeout) {
                            clearTimeout(hoverTimeout);
                        }

                        // Set new timeout for 3 seconds
                        hoverTimeout = setTimeout(() => {
                            // Fade out nodes that don't belong to the hovered company
                            node.transition()
                                .duration(300)
                                .attr('opacity', n => {
                                    // Keep "You" node (depth 0) fully visible
                                    if (n.depth === 0) return 1;

                                    // Get the company for this node
                                    const nodeCompany = n.data.company;

                                    // Fade out if not part of hovered company
                                    if (nodeCompany !== companyName) {
                                        return 0.2;
                                    }
                                    return 1;
                                });

                            text.transition()
                                .duration(300)
                                .attr('opacity', n => {
                                    // Keep "You" label fully visible
                                    if (n.depth === 0) return 1;

                                    // Get the company for this node
                                    const nodeCompany = n.data.company;

                                    // Fade out labels if not part of hovered company
                                    if (nodeCompany !== companyName) {
                                        return 0.2;
                                    }
                                    return 1;
                                });

                            link.transition()
                                .duration(300)
                                .attr('opacity', l => {
                                    // Get company from source or target
                                    const linkCompany = l.source.data.company || l.target.data.company;

                                    // Fade links that don't belong to the hovered company
                                    if (linkCompany !== companyName) {
                                        return 0.1;
                                    }
                                    return 0.6;
                                });
                        }, 3000); // 3 seconds delay
                    } else if (d.depth === 2 && d.data.type === 'profession') {
                        // Show profession name and count
                        const count = d.data.employeeCount || 0;
                        tooltipData.name = `${d.data.name} (${count} connections)`;
                    }
                    showTooltip(event, tooltipData);
                })
                .on('mouseout', (event, d) => {
                    hideTooltip();

                    // Clear hover timeout if mouse leaves before 3 seconds
                    if (hoverTimeout) {
                        clearTimeout(hoverTimeout);
                        hoverTimeout = null;
                    }

                    // Reset opacity for all nodes if we were in hover state
                    if (d.depth === 1 && hoveredCompany) {
                        hoveredCompany = null;

                        node.transition()
                            .duration(300)
                            .attr('opacity', 1);

                        text.transition()
                            .duration(300)
                            .attr('opacity', 1);

                        link.transition()
                            .duration(300)
                            .attr('opacity', 0.6);
                    }
                });

            // Create labels with different sizes
            text = g.append('g')
                .selectAll('text')
                .data(nodes)
                .join('text')
                .text(d => {
                    const name = d.data.name;
                    if (d.depth === 1) {
                        // Show company name with count (use employeeCount when members are hidden)
                        const count = showMembers ? (d.children ? d.children.length : 0) : (d.data.employeeCount || 0);
                        return `${name} (${count})`;
                    }
                    if (d.depth === 2 && d.data.type === 'profession') {
                        // Show profession name with count (use employeeCount to show total even when people are hidden)
                        const count = d.data.employeeCount || 0;
                        return `${name} (${count})`;
                    }
                    return name.length > 15 ? name.substring(0, 15) + '...' : name;
                })
                .attr('font-size', d => {
                    if (d.depth === 0) return 16;  // You - largest text
                    if (d.depth === 1) return 11;  // Company - medium text
                    if (d.depth === 2 && d.data.type === 'profession') return 9;  // Profession - small-medium text
                    return 8;                       // Person - smallest text
                })
                .attr('font-weight', d => {
                    if (d.depth <= 1) return 'bold';
                    if (d.depth === 2 && d.data.type === 'profession') return '600';  // Semi-bold for professions
                    return 'normal';
                })
                .attr('dx', d => {
                    if (d.depth === 0) return 0;
                    if (d.depth === 1) return 18;
                    if (d.depth === 2 && d.data.type === 'profession') return 15;  // Profession offset
                    return 10;
                })
                .attr('dy', d => d.depth === 0 ? -30 : 4)
                .attr('text-anchor', d => d.depth === 0 ? 'middle' : 'start')
                .attr('fill', '#fff')
                .style('pointer-events', 'none');
            
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                text
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });

            // Add click handler to SVG background to reset highlight
            svg.on('click', () => {
                resetHighlight();
            });
        }

        // Track currently highlighted company
        let highlightedCompany = null;

        function handleCompanyHighlight(companyNode) {
            const companyId = companyNode.data.id;

            // Toggle: if clicking the same company, reset
            if (highlightedCompany === companyId) {
                resetHighlight();
                return;
            }

            highlightedCompany = companyId;
            const companyName = companyNode.data.company;

            // Get IDs of all employees in this company
            const employeeIds = new Set();
            if (companyNode.children) {
                companyNode.children.forEach(child => {
                    employeeIds.add(child.data.id);
                });
            }

            // Dim all nodes except: You, this company, and its employees
            node.transition()
                .duration(300)
                .attr('opacity', d => {
                    if (d.depth === 0) return 1;  // You - always visible
                    if (d.depth === 1) {
                        return d.data.id === companyId ? 1 : 0.1;  // Highlight company, dim others
                    }
                    // Person nodes - only show if they belong to this company
                    return employeeIds.has(d.data.id) ? 0.8 : 0.05;
                });

            // Dim all text labels except for highlighted company and its employees
            text.transition()
                .duration(300)
                .attr('opacity', d => {
                    if (d.depth === 0) return 1;  // You - always visible
                    if (d.depth === 1) {
                        return d.data.id === companyId ? 1 : 0.1;
                    }
                    return employeeIds.has(d.data.id) ? 1 : 0.05;
                });

            // Dim links except those connected to highlighted company
            link.transition()
                .duration(300)
                .attr('stroke-opacity', d => {
                    // Highlight links from You to this company
                    if (d.source.depth === 0 && d.target.data.id === companyId) return 0.6;
                    // Highlight links from this company to its employees
                    if (d.source.data.id === companyId) return 0.6;
                    return 0.05;
                });

            // Highlight the same company in timeline chart
            highlightCompanyInTimeline(companyName);
        }

        function resetHighlight() {
            highlightedCompany = null;

            // Restore all nodes to original opacity
            node.transition()
                .duration(300)
                .attr('opacity', d => d.depth === 2 ? 0.8 : 1);

            // Restore all text labels
            text.transition()
                .duration(300)
                .attr('opacity', 1);

            // Restore all links
            link.transition()
                .duration(300)
                .attr('stroke-opacity', 0.4);

            // Reset timeline highlight
            resetTimelineHighlight();
        }

        // Timeline highlight functions
        function highlightCompanyInTimeline(companyName) {
            // Check if timeline bar groups exist (for stacked bar chart)
            const timelineGroups = d3.select('#timelineChart').selectAll('g g');
            if (timelineGroups.empty()) return;

            // Fade all bar groups and make only selected company visible
            timelineGroups.selectAll('rect').transition()
                .duration(300)
                .attr('opacity', function(d) {
                    const parentData = d3.select(this.parentNode).datum();
                    // Safety check: ensure parentData exists and has a key
                    if (!parentData || !parentData.key) return 0.9;
                    return parentData.key === companyName ? 0.9 : 0.1;
                });
        }

        function resetTimelineHighlight() {
            // Check if timeline bar groups exist
            const timelineGroups = d3.select('#timelineChart').selectAll('g g');
            if (timelineGroups.empty()) return;

            // Restore all bars to original opacity
            timelineGroups.selectAll('rect').transition()
                .duration(300)
                .attr('opacity', 0.7);
        }

        function buildTimelineChart(data, year = null) {
            console.log('Building timeline chart with', data.length, 'connections', year ? `for year ${year}` : '(all years)');

            // Filter by year if specified
            const filteredByYear = year ? data.filter(d => {
                const date = d3.timeParse('%d %b %Y')(d.connectedOn);
                return date && date.getFullYear() === year;
            }) : data;

            console.log('After year filter:', filteredByYear.length, 'connections');

            const svgElement = document.getElementById('timelineChart');
            const container = svgElement.parentElement;
            const width = container.clientWidth;
            const height = Math.max(container.clientHeight - 80, 400);
            const margin = {top: 40, right: 120, bottom: 80, left: 60};
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;

            // Clear existing
            d3.select('#timelineChart').selectAll('*').remove();

            // Parse dates and group by month and company
            const parseDate = d3.timeParse('%d %b %Y');
            const dataByDate = new Map();

            let parsedCount = 0;
            let skippedNoDate = 0;
            let skippedParseError = 0;

            filteredByYear.forEach(d => {
                if (!d.connectedOn) {
                    skippedNoDate++;
                    return;
                }
                const date = parseDate(d.connectedOn);
                if (!date) {
                    skippedParseError++;
                    if (skippedParseError <= 3) {
                        console.log('Failed to parse date:', d.connectedOn);
                    }
                    return;
                }

                parsedCount++;
                const monthKey = d3.timeMonth.floor(date);
                const company = d.company || 'Unknown';

                // Find existing month by comparing timestamps
                let existingMonth = null;
                for (const [key, value] of dataByDate.entries()) {
                    if (key.getTime() === monthKey.getTime()) {
                        existingMonth = key;
                        break;
                    }
                }

                if (!existingMonth) {
                    dataByDate.set(monthKey, new Map());
                    existingMonth = monthKey;
                }

                const monthData = dataByDate.get(existingMonth);
                monthData.set(company, (monthData.get(company) || 0) + 1);
            });

            console.log('Parsed dates count:', dataByDate.size);
            console.log('Successfully parsed:', parsedCount, 'Skipped (no date):', skippedNoDate, 'Skipped (parse error):', skippedParseError);

            // Get all months in range
            const allDates = Array.from(dataByDate.keys()).sort((a, b) => a - b);
            if (allDates.length === 0) {
                d3.select('#timelineChart').append('text')
                    .attr('x', width / 2)
                    .attr('y', height / 2)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#fff')
                    .text('No date information available');
                return;
            }

            const minDate = allDates[0];
            const maxDate = allDates[allDates.length - 1];

            console.log('Date range:', minDate, 'to', maxDate);

            // Create all months between min and max
            const allMonths = d3.timeMonths(minDate, d3.timeMonth.offset(maxDate, 1));

            // Get all unique companies from the actual parsed date data
            // This ensures we only use companies that actually have connection dates
            const companiesWithDates = Array.from(new Set(
                Array.from(dataByDate.values()).flatMap(monthData => Array.from(monthData.keys()))
            ));

            // Use companies from the data that have dates, filtered by selectedCompanies if applicable
            const companies = selectedCompanies.size > 0
                ? companiesWithDates.filter(c => selectedCompanies.has(c))
                : companiesWithDates;

            console.log('Total months:', allMonths.length);
            console.log('Selected companies size:', selectedCompanies.size);
            console.log('Companies for timeline:', companies);
            
            // Build complete dataset with all months
            const stackData = allMonths.map(date => {
                const obj = { date };
                // Find the matching month in dataByDate by comparing time values
                let monthData = null;
                for (const [key, value] of dataByDate.entries()) {
                    if (key.getTime() === date.getTime()) {
                        monthData = value;
                        break;
                    }
                }
                if (!monthData) monthData = new Map();

                companies.forEach(company => {
                    obj[company] = monthData.get(company) || 0;
                });
                return obj;
            });

            // Debug: Check if we have any non-zero values
            const sampleWithData = stackData.find(d => {
                return companies.some(company => d[company] > 0);
            });
            console.log('Sample month with data:', sampleWithData);
            console.log('Companies in dataByDate:', Array.from(new Set(Array.from(dataByDate.values()).flatMap(m => Array.from(m.keys())))));
            
            // Create stack
            const stack = d3.stack()
                .keys(companies)
                .order(d3.stackOrderNone)
                .offset(d3.stackOffsetNone);

            const series = stack(stackData);

            console.log('Stack data sample:', stackData.slice(0, 3));
            console.log('Series:', series.length, 'companies');
            const maxValue = d3.max(series, d => d3.max(d, d => d[1]));
            console.log('Max stack value:', maxValue);

            // Create scales
            // Use scaleBand for bars instead of scaleTime
            const x = d3.scaleBand()
                .domain(stackData.map(d => d.date))
                .range([0, innerWidth])
                .padding(0.1);

            const y = d3.scaleLinear()
                .domain([0, maxValue || 10])
                .nice()
                .range([innerHeight, 0]);
            
            // Create SVG
            const svg = d3.select('#timelineChart')
                .attr('width', width)
                .attr('height', height);
            
            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Clip path
            g.append('defs').append('clipPath')
                .attr('id', 'clip-timeline')
                .append('rect')
                .attr('width', innerWidth)
                .attr('height', innerHeight);

            const chartArea = g.append('g')
                .attr('clip-path', 'url(#clip-timeline)');

            // Draw stacked bars
            const barGroups = chartArea.selectAll('g')
                .data(series)
                .join('g')
                .attr('fill', d => companyColors[d.key] || '#999');

            const bandwidth = Math.max(x.bandwidth(), 1); // Ensure minimum width of 1px

            const bars = barGroups.selectAll('rect')
                .data(d => d)
                .join('rect')
                .attr('x', d => x(d.data.date))
                .attr('y', d => y(d[1]))
                .attr('height', d => Math.max(y(d[0]) - y(d[1]), 0)) // Ensure non-negative height
                .attr('width', bandwidth)
                .attr('opacity', 0.7)
                .style('cursor', 'pointer')
                .on('mouseover', function(event, d) {
                    // Show tooltip with company and count
                    const companyKey = d3.select(this.parentNode).datum().key;
                    const count = d[1] - d[0];
                    if (count > 0) {
                        d3.select(this).attr('opacity', 0.9);
                    }
                })
                .on('mouseout', function(event, d) {
                    d3.select(this).attr('opacity', 0.7);
                });

            console.log('Bar groups created:', barGroups.size());
            console.log('Total bars created:', bars.size());

            // Debug: Check a sample bar's attributes
            const sampleBar = bars.nodes()[0];
            if (sampleBar) {
                console.log('Sample bar attributes:', {
                    x: sampleBar.getAttribute('x'),
                    y: sampleBar.getAttribute('y'),
                    width: sampleBar.getAttribute('width'),
                    height: sampleBar.getAttribute('height')
                });
            }
            
            // Add grid lines (skip for bar chart to reduce clutter)
            // Grid doesn't work well with band scale, so we'll only show y-axis grid
            
            const yAxisGrid = g.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(y)
                    .ticks(5)
                    .tickSize(-innerWidth)
                    .tickFormat(''));
            
            yAxisGrid.selectAll('line')
                .attr('stroke', '#444')
                .attr('stroke-opacity', 0.3);
            
            // Add axes
            const xAxis = g.append('g')
                .attr('class', 'x-axis')
                .attr('transform', `translate(0,${innerHeight})`);
            
            const yAxis = g.append('g')
                .attr('class', 'y-axis');
            
            updateAxes();
            
            // Tooltip
            const tooltip = d3.select('body').append('div')
                .attr('class', 'timeline-tooltip')
                .style('position', 'absolute')
                .style('background', 'rgba(0, 0, 0, 0.9)')
                .style('color', 'white')
                .style('padding', '10px')
                .style('border-radius', '5px')
                .style('font-size', '12px')
                .style('pointer-events', 'none')
                .style('opacity', 0)
                .style('z-index', 10000);
            
            // Define zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([1, 20])
                .translateExtent([[0, 0], [innerWidth, innerHeight]])
                .filter((event) => {
                    if (event.type === 'wheel') {
                        event.preventDefault();
                        return true;
                    }
                    return !event.ctrlKey && !event.button;
                })
                .on('zoom', zoomed);

            // Hover overlay for tooltips and zoom
            const overlay = g.append('rect')
                .attr('width', innerWidth)
                .attr('height', innerHeight)
                .attr('fill', 'none')
                .style('pointer-events', 'all')
                .call(zoom)
                .on('mousemove.tooltip', handleMouseMove)
                .on('mouseout.tooltip', handleMouseOut);

            function handleMouseMove(event) {
                const [mouseX] = d3.pointer(event);

                // Find which bar we're hovering over using band scale
                const eachBand = x.step();
                const index = Math.floor(mouseX / eachBand);
                const dataPoint = stackData[index];
                
                if (dataPoint && dataPoint.date) {
                    // Build tooltip content
                    const monthYear = d3.timeFormat('%B %Y')(dataPoint.date);
                    let tooltipContent = `<strong>${monthYear}</strong><br/>`;

                    companies.forEach(company => {
                        const count = dataPoint[company] || 0;
                        if (count > 0) {
                            const color = companyColors[company] || '#999';
                            tooltipContent += `<div style="margin-top: 5px;">
                                <span style="display: inline-block; width: 10px; height: 10px; background: ${color}; margin-right: 5px;"></span>
                                ${company}: <strong>${count}</strong>
                            </div>`;
                        }
                    });

                    tooltip
                        .html(tooltipContent)
                        .style('left', (event.pageX + 15) + 'px')
                        .style('top', (event.pageY - 15) + 'px')
                        .style('opacity', 1);
                } else {
                    handleMouseOut();
                }
            }

            function handleMouseOut() {
                tooltip.style('opacity', 0);
            }

            function zoomed(event) {
                // For band scale, we manually apply the transform
                const transform = event.transform;

                // Update bars with transform
                barGroups.selectAll('rect')
                    .attr('x', d => transform.applyX(x(d.data.date)))
                    .attr('width', x.bandwidth() * transform.k);

                // Create axis scale by manually applying transform to band positions
                const transformedScale = (date) => transform.applyX(x(date));
                transformedScale.bandwidth = () => x.bandwidth() * transform.k;

                // Calculate visible range
                const [x0, x1] = [
                    transform.invertX(0),
                    transform.invertX(innerWidth)
                ];

                // Find visible data based on pixel positions
                const visibleData = stackData.filter(d => {
                    const pos = x(d.date) + x.bandwidth() / 2;
                    return pos >= x0 && pos <= x1;
                });

                // Determine tick frequency based on visible range
                let tickValues;
                const visibleMonths = visibleData.length;

                if (visibleMonths > 120) {
                    tickValues = visibleData.filter((d, i) => i % 12 === 0).map(d => d.date);
                } else if (visibleMonths > 60) {
                    tickValues = visibleData.filter((d, i) => i % 6 === 0).map(d => d.date);
                } else if (visibleMonths > 24) {
                    tickValues = visibleData.filter((d, i) => i % 3 === 0).map(d => d.date);
                } else if (visibleMonths > 12) {
                    tickValues = visibleData.filter((d, i) => i % 2 === 0).map(d => d.date);
                } else {
                    tickValues = visibleData.map(d => d.date);
                }

                // Update axis with transformed positions
                xAxis.call(g => {
                    g.selectAll('.tick').remove();

                    tickValues.forEach(date => {
                        const tick = g.append('g')
                            .attr('class', 'tick')
                            .attr('transform', `translate(${transformedScale(date) + transformedScale.bandwidth() / 2}, 0)`);

                        tick.append('line')
                            .attr('stroke', '#999')
                            .attr('y2', 6);

                        tick.append('text')
                            .attr('fill', '#fff')
                            .attr('y', 9)
                            .attr('dy', '0.71em')
                            .attr('transform', 'rotate(-45)')
                            .style('text-anchor', 'end')
                            .text(d3.timeFormat('%b %Y')(date));
                    });
                });
            }

            function updateAxes() {
                // For bar chart, show limited ticks based on data range
                const totalMonths = stackData.length;

                // Determine tick frequency based on total months
                let tickValues;
                if (totalMonths > 120) {
                    // Show every 12th month (yearly)
                    tickValues = stackData.filter((d, i) => i % 12 === 0).map(d => d.date);
                } else if (totalMonths > 60) {
                    // Show every 6th month
                    tickValues = stackData.filter((d, i) => i % 6 === 0).map(d => d.date);
                } else if (totalMonths > 24) {
                    // Show every 3rd month (quarterly)
                    tickValues = stackData.filter((d, i) => i % 3 === 0).map(d => d.date);
                } else {
                    // Show all months
                    tickValues = stackData.map(d => d.date);
                }

                xAxis.call(d3.axisBottom(x)
                    .tickValues(tickValues)
                    .tickFormat(d3.timeFormat('%b %Y')));

                xAxis.selectAll('text')
                    .attr('fill', '#fff')
                    .attr('transform', 'rotate(-45)')
                    .style('text-anchor', 'end');

                yAxis.call(d3.axisLeft(y).ticks(5));

                xAxis.selectAll('.domain, .tick line').attr('stroke', '#999');
                yAxis.selectAll('text').attr('fill', '#fff');
                yAxis.selectAll('.domain, .tick line').attr('stroke', '#999');
            }

            // Add title
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', 20)
                .attr('text-anchor', 'middle')
                .attr('font-size', 18)
                .attr('font-weight', 'bold')
                .attr('fill', '#fff')
                .text(year ? `Connections in ${year} by Company` : 'Connections Over Time by Company');

            // Add zoom instructions
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height - 5)
                .attr('text-anchor', 'middle')
                .attr('font-size', 11)
                .attr('fill', '#aaa')
                .text('Scroll to zoom ‚Ä¢ Double-click to reset');

            // Add legend
            const legend = svg.append('g')
                .attr('transform', `translate(${width - margin.right + 10}, ${margin.top})`);
            
            companies.forEach((company, i) => {
                const legendRow = legend.append('g')
                    .attr('transform', `translate(0, ${i * 20})`);
                
                legendRow.append('rect')
                    .attr('width', 15)
                    .attr('height', 15)
                    .attr('fill', companyColors[company]);
                
                legendRow.append('text')
                    .attr('x', 20)
                    .attr('y', 12)
                    .attr('font-size', 11)
                    .attr('fill', '#fff')
                    .text(company.length > 15 ? company.substring(0, 15) + '...' : company);
            });
        }
        
        function buildBubbleChart(data, year = null) {
            console.log('Building bubble chart with', data.length, 'connections', year ? `for year ${year}` : '(all years)');

            // Filter by year if specified
            const filteredByYear = year ? data.filter(d => {
                const date = new Date(d.connectedOn);
                return date && date.getFullYear() === year;
            }) : data;

            console.log('After year filter:', filteredByYear.length, 'connections');

            const width = document.getElementById('bubbleChart').clientWidth;
            const height = document.getElementById('bubbleChart').clientHeight;
            const margin = {top: 60, right: 20, bottom: 20, left: 20};

            // Clear existing
            d3.select('#bubbleChart').selectAll('*').remove();

            // Group by company
            const companyData = d3.rollup(
                filteredByYear,
                v => v.length,
                d => d.company || 'Unknown'
            );
            
            // Create hierarchy
            const root = d3.hierarchy({ children: Array.from(companyData, ([name, value]) => ({ name, value })) })
                .sum(d => d.value)
                .sort((a, b) => b.value - a.value);
            
            // Create pack layout
            const pack = d3.pack()
                .size([width - margin.left - margin.right, height - margin.top - margin.bottom])
                .padding(5);
            
            pack(root);
            
            // Create SVG
            const svg = d3.select('#bubbleChart')
                .attr('width', width)
                .attr('height', height);
            
            // Add zoom
            const zoom = d3.zoom()
                .scaleExtent([0.5, 8])
                .on('zoom', zoomed);
            
            svg.call(zoom);
            
            const g = svg.append('g')
                .attr('transform', `translate(${margin.left}, ${margin.top})`);
            
            // Tooltip
            const tooltip = d3.select('body').append('div')
                .attr('class', 'bubble-tooltip')
                .style('position', 'absolute')
                .style('background', 'rgba(0, 0, 0, 0.9)')
                .style('color', 'white')
                .style('padding', '10px')
                .style('border-radius', '5px')
                .style('font-size', '12px')
                .style('pointer-events', 'none')
                .style('opacity', 0)
                .style('z-index', 10000);
            
            // Create bubbles
            const bubbles = g.selectAll('g')
                .data(root.children)
                .join('g')
                .attr('transform', d => `translate(${d.x},${d.y})`)
                .style('cursor', 'pointer');
            
            bubbles.append('circle')
                .attr('r', d => Math.max(0, d.r || 0))
                .attr('fill', d => companyColors[d.data.name] || '#28a745')
                .attr('opacity', 0.7)
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                .on('mouseover', function(event, d) {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('opacity', 1)
                        .attr('stroke-width', 4);
                    
                    tooltip
                        .html(`
                            <strong>${d.data.name}</strong><br/>
                            <span style="color: ${companyColors[d.data.name]};">‚óè</span> ${d.value} connections<br/>
                            <span style="font-size: 10px; color: #aaa;">Click to view network graph</span>
                        `)
                        .style('left', (event.pageX + 15) + 'px')
                        .style('top', (event.pageY - 15) + 'px')
                        .style('opacity', 1);
                })
                .on('mouseout', function() {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('opacity', 0.7)
                        .attr('stroke-width', 2);
                    
                    tooltip.style('opacity', 0);
                })
                .on('click', function(event, d) {
                    // Open company network modal
                    const company = d.data.name;
                    openCompanyModal(company);
                });
            
            // Add text labels
            bubbles.each(function(d) {
                const bubble = d3.select(this);
                const textSize = Math.min(d.r / 3, 16);
                
                // Company name
                bubble.append('text')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '-0.3em')
                    .attr('font-size', textSize)
                    .attr('fill', '#fff')
                    .attr('font-weight', 'bold')
                    .style('pointer-events', 'none')
                    .text(d.data.name.length > 12 ? d.data.name.substring(0, 12) + '...' : d.data.name);
                
                // Connection count (only if bubble is large enough)
                if (d.r > 30) {
                    bubble.append('text')
                        .attr('text-anchor', 'middle')
                        .attr('dy', '1em')
                        .attr('font-size', Math.min(d.r / 4, 14))
                        .attr('fill', '#fff')
                        .style('pointer-events', 'none')
                        .text(d.value + ' connections');
                }
            });
            
            function zoomed(event) {
                g.attr('transform', `translate(${margin.left + event.transform.x}, ${margin.top + event.transform.y}) scale(${event.transform.k})`);
            }
            
            // Add title
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', 30)
                .attr('text-anchor', 'middle')
                .attr('font-size', 18)
                .attr('font-weight', 'bold')
                .attr('fill', '#fff')
                .text(year ? `Connections by Company in ${year}` : 'Connections by Company (Zoom with scroll)');
            
            // Add instructions
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', 50)
                .attr('text-anchor', 'middle')
                .attr('font-size', 12)
                .attr('fill', '#aaa')
                .text('Scroll to zoom ‚Ä¢ Click bubble to filter');
        }

        // Graph navigation functions
        function changeGraphYear(delta) {
            if (currentGraphYear === null) {
                const years = Array.from(new Set(filteredData.map(d => new Date(d.connectedOn).getFullYear()))).sort();
                currentGraphYear = delta > 0 ? years[0] : years[years.length - 1];
            } else {
                currentGraphYear += delta;
            }
            document.getElementById('graphYear').textContent = currentGraphYear;
            applyYearFilterAndRebuild();
        }

        function resetGraphYear() {
            currentGraphYear = null;
            document.getElementById('graphYear').textContent = 'All Years';
            applyYearFilterAndRebuild();
        }

        // Timeline navigation functions
        function changeTimelineYear(delta) {
            if (currentTimelineYear === null) {
                const years = Array.from(new Set(filteredData.map(d => new Date(d.connectedOn).getFullYear()))).sort();
                currentTimelineYear = delta > 0 ? years[0] : years[years.length - 1];
            } else {
                currentTimelineYear += delta;
            }
            document.getElementById('timelineYear').textContent = currentTimelineYear;
            buildTimelineChart(filteredData, currentTimelineYear);
        }

        function resetTimelineYear() {
            currentTimelineYear = null;
            document.getElementById('timelineYear').textContent = 'All Years';
            buildTimelineChart(filteredData, null);
        }

        // Bubble chart navigation functions
        function changeBubbleYear(delta) {
            if (currentBubbleYear === null) {
                const years = Array.from(new Set(filteredData.map(d => new Date(d.connectedOn).getFullYear()))).sort();
                currentBubbleYear = delta > 0 ? years[0] : years[years.length - 1];
            } else {
                currentBubbleYear += delta;
            }
            document.getElementById('bubbleYear').textContent = currentBubbleYear;
            buildBubbleChart(filteredData, currentBubbleYear);
        }

        function resetBubbleYear() {
            currentBubbleYear = null;
            document.getElementById('bubbleYear').textContent = 'All Years';
            buildBubbleChart(filteredData, null);
        }

        // Apply year filter to graph and rebuild
        function applyYearFilterAndRebuild() {
            let yearFilteredData = filteredData;

            if (currentGraphYear !== null) {
                yearFilteredData = filteredData.filter(d => {
                    const date = new Date(d.connectedOn);
                    return date.getFullYear() === currentGraphYear;
                });
            }

            // Apply company size filter
            const companyCounts = new Map();
            yearFilteredData.forEach(d => {
                const company = d.company || 'Unknown';
                companyCounts.set(company, (companyCounts.get(company) || 0) + 1);
            });

            const companySizeFilteredData = yearFilteredData.filter(d => {
                const company = d.company || 'Unknown';
                return companyCounts.get(company) >= minCompanySize;
            });

            console.log(`Year filter: ${yearFilteredData.length} connections, Company size filter (>=${minCompanySize}): ${companySizeFilteredData.length} connections`);

            // Display the filtered data
            buildGraph(companySizeFilteredData);
            updateStats();
        }

        // Update minimum company size filter
        function updateMinCompanySize(value) {
            minCompanySize = parseInt(value);
            applyYearFilterAndRebuild();
        }

        // Toggle show/hide individual members
        function toggleShowMembers(checked) {
            showMembers = checked;
            if (checked) {
                // Clear expanded companies when showing all members
                expandedCompanies.clear();
                showNotification('Showing all individual connections', 'success');
            } else {
                showNotification('Showing companies only - click a company to expand it', 'success');
            }
            applyYearFilterAndRebuild();
        }

        function toggleGroupByProfession(checked) {
            groupByProfession = checked;
            if (checked) {
                showNotification('Grouping connections by profession within companies', 'success');
            } else {
                showNotification('Profession grouping disabled', 'success');
            }
            applyYearFilterAndRebuild();
        }

        // Company Modal Functions
        function openCompanyModal(companyName) {
            // Filter data for this company
            const companyData = allData.filter(d => d.company === companyName);

            if (companyData.length === 0) {
                showNotification('No data found for ' + companyName, 'error');
                return;
            }

            // Update modal title
            document.getElementById('modalCompanyName').textContent = `${companyName} Network (${companyData.length} connections)`;

            // Show modal
            document.getElementById('companyModal').classList.add('show');

            // Build the company network graph
            setTimeout(() => buildCompanyNetworkGraph(companyName, companyData), 100);
        }

        function closeCompanyModal() {
            document.getElementById('companyModal').classList.remove('show');
            // Clear the graph
            d3.select('#companyNetworkGraph').selectAll('*').remove();
            // Reset profession color map for next modal
            professionColorMap.clear();
            professionColorIndex = 0;
            // Reset sidebar to default message
            document.getElementById('modalNodeInfo').innerHTML = '<p style="color: #6c757d; font-size: 14px; text-align: center; padding: 40px 20px;">Click on a profession to see members or a person to view details</p>';
        }

        // Close modal when clicking outside
        document.getElementById('companyModal').addEventListener('click', function(event) {
            if (event.target === this) {
                closeCompanyModal();
            }
        });

        // Close modal on Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeCompanyModal();
            }
        });

        function buildCompanyNetworkGraph(companyName, companyData) {
            const container = document.getElementById('companyNetworkGraph');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Clear existing
            d3.select('#companyNetworkGraph').selectAll('*').remove();

            // Create SVG
            const svg = d3.select('#companyNetworkGraph')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const g = svg.append('g');

            // Add zoom
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);

            // Group by profession if enabled
            const professionMap = new Map();
            companyData.forEach(person => {
                const profession = person.position || 'Unknown Position';
                if (!professionMap.has(profession)) {
                    professionMap.set(profession, []);
                }
                professionMap.get(profession).push(person);
            });

            // Create hierarchical structure: Company -> Professions -> People
            const root = {
                id: 'company_root',
                name: companyName,
                type: 'company',
                children: Array.from(professionMap.entries()).map(([professionName, people]) => ({
                    id: `profession_${professionName}`,
                    name: professionName,
                    type: 'profession',
                    employeeCount: people.length,
                    children: people.map(p => ({
                        id: p.id,
                        name: p.fullName,
                        type: 'person',
                        data: p
                    }))
                }))
            };

            // Convert to D3 hierarchy
            const hierarchy = d3.hierarchy(root);
            const links = hierarchy.links();
            const nodes = hierarchy.descendants();

            // Create force simulation
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links)
                    .id(d => d.id)
                    .distance(d => {
                        if (d.source.depth === 0) return 150; // Company -> Profession
                        return 80; // Profession -> Person
                    })
                    .strength(0.5))
                .force('charge', d3.forceManyBody().strength(d => {
                    if (d.depth === 0) return -1000; // Company
                    if (d.depth === 1) return -300;  // Professions
                    return -50; // People
                }))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => {
                    if (d.depth === 0) return 40;
                    if (d.depth === 1) return 25;
                    return 15;
                }));

            // Create links
            const link = g.append('g')
                .selectAll('line')
                .data(links)
                .join('line')
                .attr('stroke', '#999')
                .attr('stroke-opacity', 0.6)
                .attr('stroke-width', 1.5);

            // Create nodes
            const node = g.append('g')
                .selectAll('circle')
                .data(nodes)
                .join('circle')
                .attr('r', d => {
                    if (d.depth === 0) return 30;  // Company
                    if (d.depth === 1) return 15;  // Profession
                    return 8;  // Person
                })
                .attr('fill', d => {
                    if (d.depth === 0) {
                        // Company node - use company color
                        return companyColors[companyName] || '#28a745';
                    } else if (d.depth === 1) {
                        // Profession node - assign unique color per profession
                        return getProfessionColor(d.data.name);
                    } else {
                        // Person node - use parent profession's color
                        return getProfessionColor(d.parent.data.name);
                    }
                })
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                .style('cursor', 'pointer')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended))
                .on('click', (event, d) => {
                    console.log('Node clicked - depth:', d.depth, 'data:', d.data);

                    // Highlight the clicked node
                    node.attr('stroke-width', n => n === d ? 4 : 2);

                    if (d.depth === 2) {
                        // Show person details in sidebar
                        console.log('Person node clicked (depth 2)');
                        console.log('Full node data:', JSON.stringify(d.data, null, 2));

                        // The person data is stored in d.data.data
                        const personData = d.data.data;
                        const professionName = d.parent ? d.parent.data.name : 'Unknown';

                        if (personData) {
                            console.log('Calling showModalPersonDetails with:', personData);
                            showModalPersonDetails(personData, professionName);
                        } else {
                            console.error('No person data found at d.data.data');
                            showNotification('Unable to load person details', 'error');
                        }
                    } else if (d.depth === 1) {
                        // Show profession members list in sidebar
                        console.log('Profession node clicked:', d.data.name, `(${d.data.employeeCount} people)`);
                        showProfessionMembers(d.data.name, d.data.children, companyName);
                    } else if (d.depth === 0) {
                        console.log('Company node clicked:', d.data.name);
                        // Clear sidebar
                        document.getElementById('modalNodeInfo').innerHTML = '<p style="color: #6c757d; font-size: 14px; text-align: center; padding: 40px 20px;">Click on a profession to see members or a person to view details</p>';
                    }
                });

            // Create labels
            const text = g.append('g')
                .selectAll('text')
                .data(nodes)
                .join('text')
                .text(d => {
                    if (d.depth === 0) return d.data.name;
                    if (d.depth === 1) return `${d.data.name} (${d.data.employeeCount})`;
                    return d.data.name.length > 15 ? d.data.name.substring(0, 15) + '...' : d.data.name;
                })
                .attr('font-size', d => {
                    if (d.depth === 0) return 14;
                    if (d.depth === 1) return 10;
                    return 8;
                })
                .attr('font-weight', d => d.depth <= 1 ? 'bold' : 'normal')
                .attr('dx', d => d.depth === 0 ? 0 : 12)
                .attr('dy', d => d.depth === 0 ? -35 : 4)
                .attr('text-anchor', d => d.depth === 0 ? 'middle' : 'start')
                .attr('fill', 'white')
                .attr('stroke', '#1a1a2e')
                .attr('stroke-width', 0.5)
                .style('pointer-events', 'none');

            // Update positions on tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                text
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });

            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        // Profession color mapping
        const professionColorPalette = [
            '#667eea', '#764ba2', '#f093fb', '#4facfe', '#00f2fe',
            '#43e97b', '#38f9d7', '#fa709a', '#fee140', '#30cfd0',
            '#a8edea', '#fed6e3', '#c471f5', '#f64f59', '#12c2e9',
            '#f857a6', '#ff6a88', '#5f72bd', '#9921e8', '#00d2ff'
        ];
        let professionColorMap = new Map();
        let professionColorIndex = 0;

        function getProfessionColor(professionName) {
            if (!professionColorMap.has(professionName)) {
                const color = professionColorPalette[professionColorIndex % professionColorPalette.length];
                professionColorMap.set(professionName, color);
                professionColorIndex++;
            }
            return professionColorMap.get(professionName);
        }

        // Show profession members in sidebar
        function showProfessionMembers(professionName, members, companyName) {
            const professionColor = getProfessionColor(professionName);
            const sidebar = document.getElementById('modalNodeInfo');

            let html = `
                <div style="margin-bottom: 20px;">
                    <h3 style="margin: 0 0 8px 0; color: #0077b5; font-size: 16px; font-weight: 600;">${professionName}</h3>
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px;">
                        <div style="width: 12px; height: 12px; border-radius: 50%; background: ${professionColor};"></div>
                        <span style="color: #6c757d; font-size: 13px;">${members.length} member${members.length !== 1 ? 's' : ''} at ${companyName}</span>
                    </div>
                </div>
                <div style="max-height: calc(100vh - 300px); overflow-y: auto;">
            `;

            members.forEach(member => {
                const person = member.data;
                html += `
                    <div class="connection-card" onclick="showModalPersonDetails(${JSON.stringify(person).replace(/"/g, '&quot;')}, '${professionName}')" style="margin-bottom: 12px; cursor: pointer; transition: all 0.2s;">
                        <div class="connection-card-header">
                            <div>
                                <div class="connection-card-name">${person.fullName || 'Unknown'}</div>
                                <div class="connection-card-company" style="color: ${professionColor};">${person.position || professionName}</div>
                            </div>
                            <div class="connection-card-badge" style="background: ${professionColor};">View</div>
                        </div>
                        ${person.email ? `<div class="connection-card-position" style="font-size: 12px; color: #6c757d;">${person.email}</div>` : ''}
                    </div>
                `;
            });

            html += '</div>';
            sidebar.innerHTML = html;
        }

        // Calendar Day Modal Functions
        function openCalendarDayModal(date, connections) {
            const formattedDate = date.toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });

            // Update modal title
            document.getElementById('calendarDayTitle').textContent = `${connections.length} Connection${connections.length !== 1 ? 's' : ''} on ${formattedDate}`;

            // Build connections grid
            const container = document.getElementById('calendarDayConnections');

            let html = '<div class="connection-grid">';

            connections.forEach(person => {
                const companyColor = companyColors[person.company] || '#28a745';

                html += `
                    <div class="connection-card" onclick="showCalendarDayPersonDetails(${JSON.stringify(person).replace(/"/g, '&quot;')})">
                        <div class="connection-card-header">
                            <div>
                                <div class="connection-card-name">${person.fullName || 'Unknown'}</div>
                                <div class="connection-card-company" style="color: ${companyColor};">${person.company || 'N/A'}</div>
                            </div>
                            <div class="connection-card-badge" style="background: ${companyColor};">View</div>
                        </div>
                        <div class="connection-card-position">${person.position || 'No position listed'}</div>
                    </div>
                `;
            });

            html += '</div>';

            container.innerHTML = html;

            // Show modal
            document.getElementById('calendarDayModal').classList.add('show');
        }

        function closeCalendarDayModal() {
            document.getElementById('calendarDayModal').classList.remove('show');
            document.getElementById('calendarDayConnections').innerHTML = '';
        }

        function showCalendarDayPersonDetails(person) {
            // Close the calendar day modal
            closeCalendarDayModal();

            // Switch to graph view to show the sidebar
            if (currentViz !== 'graph') {
                switchViz('graph');
            }

            // Show person details in sidebar
            setTimeout(() => {
                handleNodeClick({
                    id: person.id,
                    name: person.fullName,
                    type: 'person',
                    data: person
                });
            }, 100);
        }

        // Close calendar day modal when clicking outside
        document.getElementById('calendarDayModal').addEventListener('click', function(event) {
            if (event.target === this) {
                closeCalendarDayModal();
            }
        });

        function showModalPersonDetails(person, professionName) {
            const nodeInfo = document.getElementById('modalNodeInfo');

            console.log('showModalPersonDetails called with:', { person, professionName });

            if (!person) {
                console.error('Person data is null or undefined');
                nodeInfo.innerHTML = '<p style="color: #dc3545; text-align: center; padding: 20px;">Unable to load person details</p>';
                return;
            }

            // Build the info HTML (similar to main sidebar but without company filter)
            let html = '';

            html += `<div class="info-item">
                <strong style="color: #0077b5;">üë§ Name</strong><br/>
                <span style="font-size: 16px;">${person.fullName || 'N/A'}</span>
            </div>`;

            html += `<div class="info-item">
                <strong style="color: #0077b5;">üè¢ Company</strong><br/>
                <span>${person.company || 'N/A'}</span>
            </div>`;

            html += `<div class="info-item">
                <strong style="color: #0077b5;">üíº Position</strong><br/>
                <span>${professionName || person.position || 'N/A'}</span>
            </div>`;

            if (person.email) {
                html += `<div class="info-item">
                    <strong style="color: #0077b5;">üìß Email</strong><br/>
                    <a href="mailto:${person.email}" style="color: #0077b5; text-decoration: none;">${person.email}</a>
                </div>`;
            }

            if (person.connectedOn) {
                const date = new Date(person.connectedOn);
                const formattedDate = date.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
                html += `<div class="info-item">
                    <strong style="color: #0077b5;">üìÖ Connected On</strong><br/>
                    <span>${formattedDate}</span>
                </div>`;
            }

            if (person.url) {
                html += `<div class="info-item">
                    <strong style="color: #0077b5;">üîó LinkedIn Profile</strong><br/>
                    <a href="${person.url}" target="_blank" style="color: #0077b5; text-decoration: none;">View Profile ‚Üí</a>
                </div>`;
            }

            nodeInfo.innerHTML = html;
            console.log('Person details displayed successfully');
        }

        // Calendar navigation functions
        function changeCalendarYear(delta) {
            currentCalendarYear += delta;
            document.getElementById('calendarYear').textContent = currentCalendarYear;
            buildCalendarChart(filteredData, currentCalendarYear);
        }

        function buildCalendarChart(data, year) {
            console.log('Building calendar chart for year:', year);

            // Get the parent container instead of the SVG element
            const svgElement = document.getElementById('calendarChart');
            const container = svgElement.parentElement; // Get the .graph-container div

            // Log container dimensions for debugging
            console.log('Calendar container info:', {
                containerClass: container.className,
                clientWidth: container.clientWidth,
                clientHeight: container.clientHeight,
                offsetWidth: container.offsetWidth,
                offsetHeight: container.offsetHeight,
                computedStyle: window.getComputedStyle(container).width
            });

            const width = container.clientWidth || 1200;
            const height = Math.max(container.clientHeight - 80, 600); // Ensure minimum height

            console.log('Using width:', width, 'height:', height);

            // Clear existing
            d3.select('#calendarChart').selectAll('*').remove();

            // Filter data for the selected year
            const yearData = data.filter(d => {
                const date = new Date(d.connectedOn);
                return date.getFullYear() === year;
            });

            // Aggregate connections by date
            const dateMap = d3.rollup(
                yearData,
                v => v.length,
                d => d3.timeDay.floor(new Date(d.connectedOn)).toISOString().split('T')[0]
            );

            // Convert to array for max calculation
            const counts = Array.from(dateMap.values());
            const maxCount = counts.length > 0 ? d3.max(counts) : 1;

            console.log(`Year ${year}: ${yearData.length} connections, max per day: ${maxCount}`);

            // Create color scale
            const colorScale = d3.scaleSequential()
                .domain([0, maxCount])
                .interpolator(d3.interpolateBlues);

            // Calendar dimensions - sized to fit viewport
            const cellSize = 10; // Slightly smaller cell size
            const weekGap = 1;
            const weekWidth = cellSize + weekGap;
            const monthLabelHeight = 20;
            const dayLabelWidth = 12;

            // Calculate dimensions for horizontal month layout (6 months per row)
            const monthWidth = (weekWidth * 5) + dayLabelWidth + 12; // ~5 weeks per month + labels
            const monthHeight = (weekWidth * 7) + monthLabelHeight + 15; // 7 days + label

            // Calculate total calendar size
            const totalCalendarWidth = monthWidth * 6 + 80; // 6 months per row + margins
            const totalCalendarHeight = monthHeight * 2 + 120; // 2 rows + margins

            const svg = d3.select('#calendarChart')
                .attr('width', width)
                .attr('height', height);

            // Add scrollable group
            const mainGroup = svg.append('g');

            // Title
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', 30)
                .attr('text-anchor', 'middle')
                .attr('font-size', 22)
                .attr('font-weight', 'bold')
                .attr('fill', '#fff')
                .text(`Connection Activity Calendar - ${year}`);

            // Create a group for each month - horizontal layout (months side by side)
            const months = d3.timeMonths(new Date(year, 0, 1), new Date(year, 11, 31));

            const monthGroups = mainGroup.append('g')
                .attr('transform', `translate(40, 70)`)
                .selectAll('g')
                .data(months)
                .join('g')
                .attr('transform', (d, i) => {
                    // Arrange months horizontally, 6 per row
                    const col = i % 6;
                    const row = Math.floor(i / 6);
                    return `translate(${col * monthWidth}, ${row * monthHeight})`;
                });

            // Month labels (at the top of each month)
            monthGroups.append('text')
                .attr('x', monthWidth / 2)
                .attr('y', 0)
                .attr('text-anchor', 'middle')
                .attr('font-size', 12)
                .attr('font-weight', 'bold')
                .attr('fill', '#fff')
                .text(d => d3.timeFormat('%b')(d)); // Abbreviated month name

            // Tooltip
            const tooltip = d3.select('body').append('div')
                .attr('class', 'calendar-tooltip')
                .style('position', 'absolute')
                .style('background', 'rgba(0, 0, 0, 0.9)')
                .style('color', 'white')
                .style('padding', '8px 12px')
                .style('border-radius', '5px')
                .style('font-size', '12px')
                .style('pointer-events', 'none')
                .style('opacity', 0)
                .style('z-index', 10000);

            // Create cells for each month - grid layout
            monthGroups.each(function(monthDate) {
                const group = d3.select(this);
                const monthStart = d3.timeMonth.floor(monthDate);
                const monthEnd = d3.timeMonth.offset(monthStart, 1);
                const days = d3.timeDays(monthStart, monthEnd);

                // Add day cells - positioned in weekly grid
                const cells = group.selectAll('rect')
                    .data(days)
                    .join('rect')
                    .attr('width', cellSize)
                    .attr('height', cellSize)
                    .attr('x', d => {
                        // Week number within this month
                        const weekInMonth = d3.timeWeek.count(monthStart, d);
                        return dayLabelWidth + (weekInMonth * weekWidth);
                    })
                    .attr('y', d => monthLabelHeight + (d.getDay() * weekWidth))
                    .attr('fill', d => {
                        const dateStr = d.toISOString().split('T')[0];
                        const count = dateMap.get(dateStr) || 0;
                        return count > 0 ? colorScale(count) : '#2a2a2a';
                    })
                    .attr('stroke', '#444')
                    .attr('stroke-width', 0.5)
                    .attr('rx', 1)
                    .style('cursor', 'pointer')
                    .on('mouseover', function(event, d) {
                        const dateStr = d.toISOString().split('T')[0];
                        const count = dateMap.get(dateStr) || 0;

                        d3.select(this)
                            .attr('stroke', '#fff')
                            .attr('stroke-width', 2);

                        tooltip
                            .html(`
                                <strong>${d3.timeFormat('%B %d, %Y')(d)}</strong><br/>
                                ${count} connection${count !== 1 ? 's' : ''}
                            `)
                            .style('left', (event.pageX + 15) + 'px')
                            .style('top', (event.pageY - 15) + 'px')
                            .style('opacity', 1);
                    })
                    .on('mouseout', function() {
                        d3.select(this)
                            .attr('stroke', '#444')
                            .attr('stroke-width', 0.5);

                        tooltip.style('opacity', 0);
                    })
                    .on('click', function(event, d) {
                        const dateStr = d.toISOString().split('T')[0];
                        const count = dateMap.get(dateStr) || 0;

                        if (count > 0) {
                            // Find all connections for this day
                            const dayConnections = data.filter(conn => {
                                const connDate = new Date(conn.connectedOn);
                                return connDate.toISOString().split('T')[0] === dateStr;
                            });

                            openCalendarDayModal(d, dayConnections);
                        }
                    });

                // Add day of week labels (on the left side)
                if (monthDate.getMonth() === 0 || monthDate.getMonth() === 6) {
                    const weekdays = ['S', 'M', 'T', 'W', 'T', 'F', 'S'];
                    group.selectAll('text.weekday')
                        .data(weekdays)
                        .join('text')
                        .attr('class', 'weekday')
                        .attr('x', dayLabelWidth - 3)
                        .attr('y', (d, i) => monthLabelHeight + (i * weekWidth) + cellSize / 2)
                        .attr('dy', '0.3em')
                        .attr('text-anchor', 'end')
                        .attr('font-size', 8)
                        .attr('fill', '#999')
                        .text(d => d);
                }
            });

            // Legend
            const legendWidth = Math.min(300, width - 100);
            const legendHeight = 20;
            const legendX = Math.max(60, width - legendWidth - 40);
            const legendY = height - 50;

            const legendScale = d3.scaleLinear()
                .domain([0, maxCount])
                .range([0, legendWidth]);

            const legend = svg.append('g')
                .attr('transform', `translate(${legendX}, ${legendY})`);

            // Legend gradient
            const defs = svg.append('defs');
            const gradient = defs.append('linearGradient')
                .attr('id', 'legend-gradient');

            gradient.selectAll('stop')
                .data(d3.range(0, 1.1, 0.1))
                .join('stop')
                .attr('offset', d => d)
                .attr('stop-color', d => colorScale(d * maxCount));

            legend.append('rect')
                .attr('width', legendWidth)
                .attr('height', legendHeight)
                .style('fill', 'url(#legend-gradient)')
                .attr('stroke', '#fff')
                .attr('stroke-width', 1);

            // Legend axis
            const legendAxis = d3.axisBottom(legendScale)
                .ticks(5)
                .tickFormat(d => Math.round(d));

            legend.append('g')
                .attr('transform', `translate(0, ${legendHeight})`)
                .call(legendAxis)
                .call(g => g.select('.domain').attr('stroke', '#fff'))
                .call(g => g.selectAll('.tick line').attr('stroke', '#fff'))
                .call(g => g.selectAll('.tick text').attr('fill', '#fff').attr('font-size', 10));

            legend.append('text')
                .attr('x', -10)
                .attr('y', legendHeight / 2)
                .attr('dy', '0.3em')
                .attr('text-anchor', 'end')
                .attr('font-size', 11)
                .attr('fill', '#fff')
                .text('Connections per day:');

            // Summary stats
            svg.append('text')
                .attr('x', 40)
                .attr('y', height - 20)
                .attr('font-size', 12)
                .attr('fill', '#aaa')
                .text(`Total connections in ${year}: ${yearData.length} ‚Ä¢ Peak day: ${maxCount} connections`);

            // Add zoom and pan
            const zoom = d3.zoom()
                .scaleExtent([0.5, 6])
                .on('zoom', (event) => {
                    mainGroup.attr('transform', event.transform);
                });

            svg.call(zoom);

            // Set initial zoom to fit content perfectly in viewport
            const scaleToFit = Math.min(
                (width - 100) / totalCalendarWidth,
                (height - 140) / totalCalendarHeight
            ) * 0.98;

            // Center the calendar horizontally
            const translateX = (width - (totalCalendarWidth * scaleToFit)) / 2;
            svg.call(zoom.transform, d3.zoomIdentity
                .translate(translateX, 0)
                .scale(scaleToFit));

            // Instructions
            svg.append('text')
                .attr('x', width - 40)
                .attr('y', height - 20)
                .attr('text-anchor', 'end')
                .attr('font-size', 11)
                .attr('fill', '#aaa')
                .text('Scroll to zoom ‚Ä¢ Drag to pan');
        }
        
        function drag(simulation) {
            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }
            
            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }
            
            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }
            
            return d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended);
        }
        
        // Show company members in main graph sidebar
        function showMainGraphCompanyMembers(companyNode) {
            console.log('showMainGraphCompanyMembers called with:', companyNode);
            console.log('groupByProfession:', groupByProfession);
            console.log('companyNode.children:', companyNode.children);

            const sidebar = document.getElementById('nodeInfo');
            const companyName = companyNode.name || companyNode.data?.name;
            const companyColor = companyColors[companyName] || '#28a745';

            // Get all members - need to traverse the hierarchy
            let allMembers = [];

            if (groupByProfession && companyNode.children) {
                // When grouped by profession, children are profession nodes
                companyNode.children.forEach(professionNode => {
                    console.log('Processing profession node:', professionNode);
                    if (professionNode.children) {
                        professionNode.children.forEach(personNode => {
                            console.log('Person node:', personNode);
                            console.log('Person node.data:', personNode.data);
                            console.log('Person node.data.data:', personNode.data.data);
                            // The actual person data is in personNode.data.data
                            if (personNode.data && personNode.data.data) {
                                allMembers.push(personNode.data.data);
                            } else if (personNode.data) {
                                allMembers.push(personNode.data);
                            }
                        });
                    }
                });
            } else if (companyNode.children) {
                // Direct children are people
                companyNode.children.forEach(personNode => {
                    console.log('Processing person node:', personNode);
                    console.log('Person node.data:', personNode.data);
                    console.log('Person node.data.data:', personNode.data.data);
                    // The actual person data is in personNode.data.data
                    if (personNode.data && personNode.data.data) {
                        allMembers.push(personNode.data.data);
                    } else if (personNode.data) {
                        allMembers.push(personNode.data);
                    }
                });
            } else {
                // Fallback: get members from filteredData
                console.log('No children found, using filteredData fallback');
                allMembers = filteredData.filter(person => person.company === companyName);
            }

            console.log('Total members found:', allMembers.length);

            let html = `
                <div style="margin-bottom: 20px;">
                    <h3 style="margin: 0 0 8px 0; color: #0077b5; font-size: 16px; font-weight: 600;">üè¢ ${companyName}</h3>
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px;">
                        <div style="width: 12px; height: 12px; border-radius: 50%; background: ${companyColor};"></div>
                        <span style="color: #6c757d; font-size: 13px;">${allMembers.length} connection${allMembers.length !== 1 ? 's' : ''}</span>
                    </div>
                </div>
                <div style="max-height: calc(100vh - 400px); overflow-y: auto;">
            `;

            allMembers.forEach(person => {
                html += `
                    <div class="connection-card" onclick='handleNodeClick({type: "person", data: ${JSON.stringify(person).replace(/'/g, "\\'")}})' style="margin-bottom: 12px; cursor: pointer; transition: all 0.2s;">
                        <div class="connection-card-header">
                            <div>
                                <div class="connection-card-name">${person.fullName || 'Unknown'}</div>
                                <div class="connection-card-company" style="color: ${companyColor};">${person.position || 'No position'}</div>
                            </div>
                            <div class="connection-card-badge" style="background: ${companyColor};">View</div>
                        </div>
                        ${person.email ? `<div class="connection-card-position" style="font-size: 12px; color: #6c757d;">${person.email}</div>` : ''}
                    </div>
                `;
            });

            html += '</div>';
            sidebar.innerHTML = html;
        }

        // Show profession members in main graph sidebar
        function showMainGraphProfessionMembers(professionNode) {
            console.log('showMainGraphProfessionMembers called with:', professionNode);

            const sidebar = document.getElementById('nodeInfo');
            const professionName = professionNode.name || professionNode.data?.name;
            const companyName = professionNode.company || professionNode.data?.company || 'Unknown Company';
            const professionColor = getProfessionColor(professionName);

            // Get all members from children
            let allMembers = [];
            if (professionNode.children) {
                professionNode.children.forEach(personNode => {
                    console.log('Person node in profession:', personNode);
                    console.log('Person node.data:', personNode.data);
                    console.log('Person node.data.data:', personNode.data.data);
                    // The actual person data is in personNode.data.data
                    if (personNode.data && personNode.data.data) {
                        allMembers.push(personNode.data.data);
                    } else if (personNode.data) {
                        allMembers.push(personNode.data);
                    }
                });
            } else {
                // Fallback: get members from filteredData by position
                console.log('No children found for profession, using filteredData fallback');
                allMembers = filteredData.filter(person =>
                    person.position === professionName && person.company === companyName
                );
            }

            console.log('Total profession members found:', allMembers.length);

            let html = `
                <div style="margin-bottom: 20px;">
                    <h3 style="margin: 0 0 8px 0; color: #0077b5; font-size: 16px; font-weight: 600;">üíº ${professionName}</h3>
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                        <div style="width: 12px; height: 12px; border-radius: 50%; background: ${professionColor};"></div>
                        <span style="color: #6c757d; font-size: 13px;">${allMembers.length} member${allMembers.length !== 1 ? 's' : ''}</span>
                    </div>
                    <div style="color: #6c757d; font-size: 12px; margin-bottom: 16px;">at ${companyName}</div>
                </div>
                <div style="max-height: calc(100vh - 400px); overflow-y: auto;">
            `;

            allMembers.forEach(person => {
                html += `
                    <div class="connection-card" onclick='handleNodeClick({type: "person", data: ${JSON.stringify(person).replace(/'/g, "\\'")}})' style="margin-bottom: 12px; cursor: pointer; transition: all 0.2s;">
                        <div class="connection-card-header">
                            <div>
                                <div class="connection-card-name">${person.fullName || 'Unknown'}</div>
                                <div class="connection-card-company" style="color: ${professionColor};">${person.position || professionName}</div>
                            </div>
                            <div class="connection-card-badge" style="background: ${professionColor};">View</div>
                        </div>
                        ${person.email ? `<div class="connection-card-position" style="font-size: 12px; color: #6c757d;">${person.email}</div>` : ''}
                    </div>
                `;
            });

            html += '</div>';
            sidebar.innerHTML = html;
        }

        function handleNodeClick(nodeData) {
            console.log('=== handleNodeClick called ===');
            console.log('nodeData:', nodeData);
            console.log('nodeData.type:', nodeData.type);
            console.log('nodeData.depth:', nodeData.depth);

            selectedNode = nodeData;

            // Show sidebar
            document.getElementById('sidebar').classList.add('active');

            if (nodeData.type === 'central') {
                console.log('Handling central node');
                document.getElementById('nodeInfo').innerHTML = `
                    <div class="info-item">
                        <strong style="color: #0077b5;">üë§ Name</strong><br/>
                        <span style="font-size: 16px;">You (Central Node)</span>
                    </div>
                    <div class="info-item">
                        <strong style="color: #0077b5;">üìä Total Connections</strong><br/>
                        <span style="font-size: 16px;">${allData.length}</span>
                    </div>
                `;
            } else if (nodeData.type === 'company') {
                console.log('Handling company node - calling showMainGraphCompanyMembers');
                // Show company members list
                showMainGraphCompanyMembers(nodeData);
            } else if (nodeData.type === 'profession') {
                console.log('Handling profession node - calling showMainGraphProfessionMembers');
                // Show profession members list
                showMainGraphProfessionMembers(nodeData);
            } else {
                // Person node - show individual details
                const data = nodeData.data;
                let html = '';

                html += `<div class="info-item">
                    <strong style="color: #0077b5;">üë§ Name</strong><br/>
                    <span style="font-size: 16px;">${data.fullName || 'N/A'}</span>
                </div>`;

                if (data.company) {
                    html += `<div class="info-item">
                        <strong style="color: #0077b5;">üè¢ Company</strong><br/>
                        <span>${data.company}</span>
                    </div>`;
                }

                if (data.position) {
                    html += `<div class="info-item">
                        <strong style="color: #0077b5;">üíº Position</strong><br/>
                        <span>${data.position}</span>
                    </div>`;
                }

                if (data.email) {
                    html += `<div class="info-item">
                        <strong style="color: #0077b5;">üìß Email</strong><br/>
                        <a href="mailto:${data.email}" style="color: #0077b5; text-decoration: none;">${data.email}</a>
                    </div>`;
                }

                if (data.connectedOn) {
                    const date = new Date(data.connectedOn);
                    const formattedDate = date.toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    });
                    html += `<div class="info-item">
                        <strong style="color: #0077b5;">üìÖ Connected On</strong><br/>
                        <span>${formattedDate}</span>
                    </div>`;
                }

                if (data.url) {
                    html += `<div class="info-item">
                        <strong style="color: #0077b5;">üîó LinkedIn Profile</strong><br/>
                        <a href="${data.url}" target="_blank" style="color: #0077b5; text-decoration: none;">View Profile ‚Üí</a>
                    </div>`;
                }

                document.getElementById('nodeInfo').innerHTML = html;
            }
        }
        
        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY - 10) + 'px';
            tooltip.textContent = d.name;
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }
        
        function handleSearch() {
            const query = document.getElementById('searchBox').value.toLowerCase().trim();
            applyFilters();
        }
        
        function applyFilters() {
            console.log('=== APPLY FILTERS CALLED ===');
            const searchQuery = document.getElementById('searchBox').value.toLowerCase().trim();

            console.log('Search query:', searchQuery);

            filteredData = allData.filter(d => {
                const matchSearch = !searchQuery ||
                    d.fullName.toLowerCase().includes(searchQuery) ||
                    d.company.toLowerCase().includes(searchQuery) ||
                    d.position.toLowerCase().includes(searchQuery) ||
                    d.email.toLowerCase().includes(searchQuery);

                return matchSearch;
            });

            if (allData.length > 0) {
                console.log(`After filter: ${filteredData.length} connections`);
                applyYearFilterAndRebuild();
                buildTimelineChart(filteredData, currentTimelineYear);
                buildBubbleChart(filteredData, currentBubbleYear);
            }
        }
        
        function resetView() {
            document.getElementById('searchBox').value = '';
            filteredData = [...allData];
            if (allData.length > 0) {
                applyYearFilterAndRebuild();
                buildTimelineChart(filteredData, currentTimelineYear);
                buildBubbleChart(filteredData, currentBubbleYear);
            }
            selectedNode = null;
        }
        
        function toggleSidebar() {
            document.getElementById('sidebar').classList.toggle('active');
        }

        function closeSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.remove('active');

            // Clear any selected node highlighting
            if (selectedNode) {
                selectedNode = null;
                // Redraw to remove highlighting
                if (currentView === 'graph') {
                    applyYearFilterAndRebuild();
                }
            }
        }

        function exportGraph() {
            const exportData = {
                connections: allData,
                stats: {
                    total: allData.length,
                    filtered: filteredData.length
                },
                exportDate: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'linkedin_connections_export.json';
            a.click();
            URL.revokeObjectURL(url);

            showNotification('Graph exported successfully!', 'success');
        }

        async function downloadSampleConnections() {
            try {
                const response = await fetch('Connections.csv');
                if (!response.ok) {
                    throw new Error('Connections.csv file not found');
                }
                const csvData = await response.text();

                const blob = new Blob([csvData], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'sample_connections.csv';
                a.click();
                URL.revokeObjectURL(url);

                showNotification('Sample connections CSV downloaded!', 'success');
            } catch (error) {
                console.error('Error downloading Connections.csv:', error);
                showNotification('Error: Connections.csv file not found. Please make sure it exists in the same folder.', 'error');
            }
        }

        async function downloadSamplePositions() {
            try {
                const response = await fetch('Positions.csv');
                if (!response.ok) {
                    throw new Error('Positions.csv file not found');
                }
                const csvData = await response.text();

                const blob = new Blob([csvData], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'sample_positions.csv';
                a.click();
                URL.revokeObjectURL(url);

                showNotification('Sample positions CSV downloaded!', 'success');
            } catch (error) {
                console.error('Error downloading Positions.csv:', error);
                showNotification('Error: Positions.csv file not found. Please make sure it exists in the same folder.', 'error');
            }
        }
        
        function updateStats() {
            // Update all panel header counts
            const count = filteredData.length;
            const countText = `${count} connections`;

            // Update Network Graph panel
            const graphCountEl = document.getElementById('connectionCount');
            graphCountEl.style.display = 'inline-block';
            graphCountEl.textContent = countText;

            // Update Timeline panel
            const timelineCountEl = document.getElementById('timelineConnectionCount');
            timelineCountEl.style.display = 'inline-block';
            timelineCountEl.textContent = countText;

            // Update Bubble Chart panel
            const bubbleCountEl = document.getElementById('bubbleConnectionCount');
            bubbleCountEl.style.display = 'inline-block';
            bubbleCountEl.textContent = countText;

            // Update Calendar panel
            const calendarCountEl = document.getElementById('calendarConnectionCount');
            calendarCountEl.style.display = 'inline-block';
            calendarCountEl.textContent = countText;

            // Update Career panel (shows total connections from allData)
            const careerCountEl = document.getElementById('careerConnectionCount');
            careerCountEl.style.display = 'inline-block';
            careerCountEl.textContent = `${allData.length} connections`;
        }
        
        function showLoading(show) {
            const loading = document.getElementById('loading');
            if (show) {
                loading.classList.remove('hidden');
                document.getElementById('loadingText').textContent = 'Loading connections...';
            } else {
                loading.classList.add('hidden');
            }
        }
        
        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type} show`;
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }
        
        // Career Timeline Functions
        let careerChart = null;

        function loadCareerCSV() {
            document.getElementById('careerCsvFile').click();
        }

        document.getElementById('careerCsvFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                complete: function(results) {
                    console.log('Career CSV loaded:', results.data);
                    buildCareerTimeline(results.data);
                    document.getElementById('careerStatus').textContent = `${results.data.length} positions loaded`;
                    document.getElementById('careerStatus').style.display = 'inline-block';
                },
                error: function(error) {
                    console.error('Error parsing career CSV:', error);
                    showNotification('Error loading career CSV file', 'error');
                }
            });
        });

        function buildCareerTimeline(data) {
            // Clear previous chart
            if (careerChart) {
                careerChart.dispose();
            }

            // Count connections per company from LinkedIn data (if loaded)
            const companyCounts = {};
            if (allData && allData.length > 0) {
                allData.forEach(conn => {
                    const company = conn.company || 'Unknown';
                    companyCounts[company] = (companyCounts[company] || 0) + 1;
                });
            }

            // Create timeline chart
            careerChart = anychart.timeline();

            // Set chart title
            careerChart.title('Professional Career Timeline');

            // Prepare data for moment series (the info boxes)
            const titleDescData = [];
            const locationData = [];
            const connectionsData = [];

            // Create a range series for each position
            data.forEach((position, index) => {
                const startDate = parseCareerDate(position['Started On']);
                const endDate = position['Finished On'] ? parseCareerDate(position['Finished On']) : new Date();
                const midDate = new Date((startDate.getTime() + endDate.getTime()) / 2);
                const color = getCareerColor(position['Company Name']);
                const title = position['Title'];
                const company = position['Company Name'];
                const description = position['Description'] || '';
                const location = position['Location'] || '';
                const connectionCount = companyCounts[company] || 0;

                // Add data for moment series (info boxes)
                // Box 1: Title + Description
                titleDescData.push({
                    x: midDate.getTime(),
                    title: title,
                    company: company,
                    description: description,
                    color: color
                });

                // Box 2: Location
                if (location) {
                    locationData.push({
                        x: midDate.getTime(),
                        location: location,
                        company: company,
                        color: color
                    });
                }

                // Box 3: Connections
                if (connectionCount > 0) {
                    connectionsData.push({
                        x: midDate.getTime(),
                        count: connectionCount,
                        company: company,
                        color: color
                    });
                }

                // Create range series with the position data (the timeline bar)
                var series = careerChart.range([
                    [company, startDate.getTime(), endDate.getTime()]
                ]);

                // Set the bar color
                series.fill(color);
                series.stroke(color);

                // Configure bar height
                series.height(25);

                // Enable labels on the bar to show company name
                series.labels().enabled(true);
                series.labels().fontColor('white');
                series.labels().fontSize(12);
                series.labels().fontWeight('bold');

                // Simplified tooltip
                series.tooltip().useHtml(true);
                series.tooltip().titleFormat('<h5>{%x}</h5>');
                series.tooltip().format(function() {
                    const startDate = new Date(this.start);
                    const endDate = new Date(this.end);
                    const monthsDiff = Math.round((endDate - startDate) / (1000 * 60 * 60 * 24 * 30));
                    const years = Math.floor(monthsDiff / 12);
                    const months = monthsDiff % 12;
                    const duration = years > 0 ? `${years}y ${months}m` : `${months}m`;

                    return `<div style="padding: 10px;">
                        <div style="margin-bottom: 3px;">${formatCareerDate(startDate)} - ${formatCareerDate(endDate)}</div>
                        <div style="margin-bottom: 5px; color: #666;">Duration: ${duration}</div>
                        <div style="font-size: 11px; color: #0077b5; margin-top: 5px;">Click to view network</div>
                    </div>`;
                });

                // Add click listener to open company network modal
                series.listen('pointClick', function(e) {
                    const clickedCompany = company;
                    console.log('Career timeline bar clicked:', clickedCompany);

                    // Check if LinkedIn data is loaded
                    if (!allData || allData.length === 0) {
                        showNotification('Please load LinkedIn connections data first', 'error');
                        return;
                    }

                    // Open the company network modal
                    openCompanyModal(clickedCompany);
                });
            });

            // Create moment series for info boxes

            // 1. Title + Description boxes (topmost)
            if (titleDescData.length > 0) {
                var titleDescSeries = careerChart.moment(titleDescData.map(d => ({
                    x: d.x,
                    value: 'title-desc'
                })));

                titleDescSeries.labels().enabled(true);
                titleDescSeries.labels().useHtml(true);
                titleDescSeries.labels().padding(5);
                titleDescSeries.labels().format(function() {
                    const data = titleDescData[this.index];
                    const shortDesc = data.description.length > 100 ? data.description.substring(0, 100) + '...' : data.description;
                    return `<div style="padding: 8px; background: white; border-radius: 5px; border-left: 4px solid ${data.color}; box-shadow: 0 2px 4px rgba(0,0,0,0.1); max-width: 300px;">
                        <div style="font-weight: bold; color: #0077b5; margin-bottom: 3px;">${data.title}</div>
                        ${data.description ? `<div style="font-size: 11px; color: #555;">${shortDesc}</div>` : ''}
                    </div>`;
                });
                titleDescSeries.tooltip().enabled(false);
            }

            // 2. Location boxes (middle)
            if (locationData.length > 0) {
                var locationSeries = careerChart.moment(locationData.map(d => ({
                    x: d.x,
                    value: 'location'
                })));

                locationSeries.labels().enabled(true);
                locationSeries.labels().useHtml(true);
                locationSeries.labels().padding(5);
                locationSeries.labels().format(function() {
                    const data = locationData[this.index];
                    return `<div style="padding: 6px 10px; background: white; border-radius: 5px; border-left: 4px solid ${data.color}; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <div style="font-size: 11px; color: #666;">üìç ${data.location}</div>
                    </div>`;
                });
                locationSeries.tooltip().enabled(false);
            }

            // 3. Connections boxes (lowest, just above the bar)
            if (connectionsData.length > 0) {
                var connectionsSeries = careerChart.moment(connectionsData.map(d => ({
                    x: d.x,
                    value: 'connections'
                })));

                connectionsSeries.labels().enabled(true);
                connectionsSeries.labels().useHtml(true);
                connectionsSeries.labels().padding(5);
                connectionsSeries.labels().format(function() {
                    const data = connectionsData[this.index];
                    return `<div style="padding: 6px 10px; background: white; border-radius: 5px; border-left: 4px solid ${data.color}; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <div style="font-size: 11px; color: #28a745; font-weight: bold;">üë• ${data.count} connections</div>
                    </div>`;
                });
                connectionsSeries.tooltip().enabled(false);
            }

            // Configure axis
            var axis = careerChart.axis();
            axis.height(25);

            // Enable scroller
            careerChart.scroller().enabled(true);

            // Set container and draw
            careerChart.container('careerTimeline');
            careerChart.background().fill('#1a1a2e');
            careerChart.draw();

            showNotification('Career timeline loaded successfully!', 'success');
        }

        function parseCareerDate(dateStr) {
            if (!dateStr) return new Date();

            // Handle format like "Jul 2022" or "Feb 2016"
            const parts = dateStr.trim().split(' ');
            if (parts.length === 2) {
                const months = {
                    'Jan': 0, 'Feb': 1, 'Mar': 2, 'Apr': 3, 'May': 4, 'Jun': 5,
                    'Jul': 6, 'Aug': 7, 'Sep': 8, 'Oct': 9, 'Nov': 10, 'Dec': 11
                };
                const month = months[parts[0]];
                const year = parseInt(parts[1]);
                return new Date(year, month, 1);
            }

            return new Date(dateStr);
        }

        function formatCareerDate(date) {
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                          'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            return `${months[date.getMonth()]} ${date.getFullYear()}`;
        }

        function getCareerColor(companyName) {
            // Define color palette for career timeline
            const colors = [
                '#0077b5', '#28a745', '#dc3545', '#ffc107', '#17a2b8',
                '#6f42c1', '#fd7e14', '#20c997', '#e83e8c', '#6c757d',
                '#007bff', '#28a745', '#ffc107', '#dc3545', '#17a2b8'
            ];

            // Check if company already has a color assigned from LinkedIn connections
            if (companyColors[companyName]) {
                return companyColors[companyName];
            }

            // Otherwise assign a new color based on current companies count
            const colorIndex = Object.keys(companyColors).length % colors.length;
            companyColors[companyName] = colors[colorIndex];
            return companyColors[companyName];
        }

        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            console.log('=== WINDOW RESIZE TRIGGERED ===');
            if (allData.length > 0) {
                // Debounce resize to avoid multiple calls
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    console.log('Rebuilding visualizations after resize');
                    if (currentViz === 'graph') {
                        applyYearFilterAndRebuild();
                    } else if (currentViz === 'timeline') {
                        buildTimelineChart(filteredData, currentTimelineYear);
                    } else if (currentViz === 'bubble') {
                        buildBubbleChart(filteredData, currentBubbleYear);
                    } else if (currentViz === 'calendar') {
                        buildCalendarChart(filteredData, currentCalendarYear);
                    } else if (currentViz === 'career' && careerChart) {
                        careerChart.draw();
                    }
                }, 250);
            }
        });
    </script>
</body>
</html>