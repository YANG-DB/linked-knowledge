<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LinkedIn Knowledge Graph Explorer</title>
    
    <!-- PapaParse for CSV parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    
    <!-- D3.js for graph visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>

    <!-- AnyChart for timeline visualization -->
    <script src="https://cdn.anychart.com/releases/v8/js/anychart-base.min.js"></script>
    <script src="https://cdn.anychart.com/releases/v8/js/anychart-timeline.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
            flex-direction: column;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .header h1 {
            color: #0077b5;
            font-size: 24px;
            font-weight: 600;
        }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .search-box {
            padding: 8px 15px;
            border: 2px solid #ddd;
            border-radius: 20px;
            font-size: 14px;
            width: 250px;
            transition: border-color 0.3s;
        }

        .search-box:focus {
            outline: none;
            border-color: #0077b5;
        }

        .btn {
            padding: 8px 20px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
            background: #0077b5;
            color: white;
        }

        .btn:hover {
            background: #005885;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
        }

        .btn-success:hover {
            background: #218838;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            flex-direction: column;
        }

        .viz-tabs {
            display: flex;
            background: rgba(255, 255, 255, 0.95);
            border-bottom: 2px solid #ddd;
            padding: 0 20px;
        }

        .viz-tab {
            padding: 12px 24px;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 14px;
            font-weight: 500;
            color: #6c757d;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .viz-tab:hover {
            color: #0077b5;
        }

        .viz-tab.active {
            color: #0077b5;
            border-bottom-color: #0077b5;
        }

        .viz-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .viz-panel {
            display: none;
            flex: 1;
            position: relative;
        }

        .graph-container {
            flex: 1;
            position: relative;
            background: #1a1a2e;
        }

        .viz-panel.active {
            display: flex;
            flex: 1;
        }

        #graph, #timelineChart, #bubbleChart {
            width: 100%;
            height: 100%;
        }

        .sidebar {
            width: 350px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            overflow-y: auto;
            box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            display: none;
        }

        .sidebar.active {
            display: block;
        }

        .sidebar h2 {
            color: #0077b5;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .company-filter-section {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .company-filter-section h3 {
            font-size: 16px;
            color: #495057;
            margin-bottom: 10px;
        }

        .company-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .company-item {
            display: flex;
            align-items: center;
            padding: 8px;
            margin-bottom: 5px;
            background: white;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .company-item:hover {
            background: #e3f2fd;
        }

        .company-item input[type="checkbox"] {
            margin-right: 10px;
            cursor: pointer;
        }

        .company-icon {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
            flex-shrink: 0;
        }

        .company-name {
            flex: 1;
            font-size: 13px;
            color: #212529;
        }

        .company-count {
            font-size: 11px;
            color: #6c757d;
            background: #e9ecef;
            padding: 2px 8px;
            border-radius: 10px;
        }

        .filter-actions {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }

        .filter-btn {
            padding: 5px 10px;
            border: none;
            border-radius: 5px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-btn.select-all {
            background: #28a745;
            color: white;
        }

        .filter-btn.select-all:hover {
            background: #218838;
        }

        .filter-btn.clear-all {
            background: #dc3545;
            color: white;
        }

        .filter-btn.clear-all:hover {
            background: #c82333;
        }

        .node-info {
            margin-bottom: 20px;
        }

        .info-item {
            margin-bottom: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .info-label {
            font-weight: 600;
            color: #495057;
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .info-value {
            color: #212529;
            font-size: 14px;
            word-break: break-word;
        }

        .stats {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .stat-box {
            background: #e3f2fd;
            padding: 10px 15px;
            border-radius: 8px;
            text-align: center;
            flex: 1;
            min-width: 100px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #0077b5;
        }

        .stat-label {
            font-size: 12px;
            color: #6c757d;
            margin-top: 5px;
        }

        .filter-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #e9ecef;
        }

        .filter-group {
            margin-bottom: 15px;
        }

        .filter-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #495057;
            font-size: 14px;
        }

        .filter-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            z-index: 2000;
            text-align: center;
        }

        .loading.hidden {
            display: none;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #0077b5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 3000;
            display: none;
        }

        .notification.error {
            background: #dc3545;
        }

        .notification.show {
            display: block;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîó LinkedIn Knowledge Graph Explorer</h1>
            <div class="controls">
                <input type="file" id="csvFile" accept=".csv" style="display: none;">
                <button class="btn" onclick="loadCSV()">üìÅ Load CSV</button>
                <span id="connectionCount" style="background: white; padding: 8px 15px; border-radius: 20px; font-weight: 600; color: #0077b5; display: none;">0 connections</span>
                <input type="text" id="searchBox" class="search-box" placeholder="üîç Search connections..." oninput="handleSearch()">
                <button class="btn btn-secondary" onclick="resetView()">üîÑ Reset View</button>
                <button class="btn btn-secondary" onclick="toggleSidebar()">‚ÑπÔ∏è Info Panel</button>
                <button class="btn btn-success" onclick="exportGraph()">üíæ Export Graph</button>
            </div>
        </div>

        <div class="main-content">
            <div class="viz-tabs">
                <button class="viz-tab active" onclick="switchViz('graph')">üîó Network Graph</button>
                <button class="viz-tab" onclick="switchViz('timeline')">üìä Timeline</button>
                <button class="viz-tab" onclick="switchViz('bubble')">‚ö™ Bubble Chart</button>
                <button class="viz-tab" onclick="switchViz('calendar')">üìÖ Calendar</button>
                <button class="viz-tab" onclick="switchViz('career')">üíº Career Timeline</button>
            </div>
            <div class="viz-content">
                <div class="viz-panel active" id="graphPanel">
                    <div class="graph-container">
                        <div id="graphControls" style="text-align: center; padding: 20px;">
                            <button class="btn" onclick="changeGraphYear(-1)">‚Üê Previous Year</button>
                            <span id="graphYear" style="font-size: 20px; font-weight: bold; margin: 0 20px; color: white;">All Years</span>
                            <button class="btn" onclick="changeGraphYear(1)">Next Year ‚Üí</button>
                            <button class="btn btn-secondary" onclick="resetGraphYear()" style="margin-left: 20px;">Show All Years</button>
                        </div>
                        <div style="text-align: center; padding: 10px 20px; display: flex; justify-content: center; align-items: center; gap: 20px;">
                            <div>
                                <label for="minCompanySizeSelect" style="color: white; font-size: 13px; margin-right: 8px;">
                                    Min connections per company:
                                </label>
                                <select id="minCompanySizeSelect" onchange="updateMinCompanySize(this.value)"
                                        style="padding: 5px 10px; border-radius: 5px; border: 1px solid #ddd; font-size: 13px; cursor: pointer;">
                                    <option value="1">1+</option>
                                    <option value="2">2+</option>
                                    <option value="3">3+</option>
                                    <option value="5" selected>5+</option>
                                    <option value="10">10+</option>
                                    <option value="15">15+</option>
                                    <option value="20">20+</option>
                                    <option value="30">30+</option>
                                    <option value="50">50+</option>
                                </select>
                            </div>
                            <div>
                                <label style="color: white; font-size: 13px; cursor: pointer; display: flex; align-items: center; gap: 5px;">
                                    <input type="checkbox" id="showMembersCheckbox" onchange="toggleShowMembers(this.checked)" checked
                                           style="cursor: pointer; width: 16px; height: 16px;">
                                    Show individual connections
                                </label>
                            </div>
                        </div>
                        <svg id="graph"></svg>
                        <div class="tooltip" id="tooltip"></div>
                    </div>
                </div>
                <div class="viz-panel" id="timelinePanel">
                    <div class="graph-container">
                        <div id="timelineControls" style="text-align: center; padding: 20px;">
                            <button class="btn" onclick="changeTimelineYear(-1)">‚Üê Previous Year</button>
                            <span id="timelineYear" style="font-size: 20px; font-weight: bold; margin: 0 20px; color: white;">All Years</span>
                            <button class="btn" onclick="changeTimelineYear(1)">Next Year ‚Üí</button>
                            <button class="btn btn-secondary" onclick="resetTimelineYear()" style="margin-left: 20px;">Show All Years</button>
                        </div>
                        <svg id="timelineChart"></svg>
                    </div>
                </div>
                <div class="viz-panel" id="bubblePanel">
                    <div class="graph-container">
                        <div id="bubbleControls" style="text-align: center; padding: 20px;">
                            <button class="btn" onclick="changeBubbleYear(-1)">‚Üê Previous Year</button>
                            <span id="bubbleYear" style="font-size: 20px; font-weight: bold; margin: 0 20px; color: white;">All Years</span>
                            <button class="btn" onclick="changeBubbleYear(1)">Next Year ‚Üí</button>
                            <button class="btn btn-secondary" onclick="resetBubbleYear()" style="margin-left: 20px;">Show All Years</button>
                        </div>
                        <svg id="bubbleChart"></svg>
                    </div>
                </div>
                <div class="viz-panel" id="calendarPanel">
                    <div class="graph-container">
                        <div id="calendarControls" style="text-align: center; padding: 20px;">
                            <button class="btn" onclick="changeCalendarYear(-1)">‚Üê Previous Year</button>
                            <span id="calendarYear" style="font-size: 20px; font-weight: bold; margin: 0 20px; color: white;">2024</span>
                            <button class="btn" onclick="changeCalendarYear(1)">Next Year ‚Üí</button>
                        </div>
                        <svg id="calendarChart"></svg>
                    </div>
                </div>
                <div class="viz-panel" id="careerPanel">
                    <div class="graph-container">
                        <div id="careerControls" style="text-align: center; padding: 20px;">
                            <input type="file" id="careerCsvFile" accept=".csv" style="display: none;">
                            <button class="btn" onclick="loadCareerCSV()">üìÅ Load Career CSV</button>
                            <span id="careerStatus" style="background: white; padding: 8px 15px; border-radius: 20px; font-weight: 600; color: #0077b5; margin-left: 15px; display: none;"></span>
                        </div>
                        <div id="careerTimeline" style="width: 100%; height: calc(100vh - 250px);"></div>
                    </div>
                </div>
                <div class="sidebar" id="sidebar">
                <h2>Connection Details</h2>
                <div id="nodeInfo">
                    <p style="color: #6c757d; font-size: 14px;">Click on a node to view details</p>
                </div>
                <div class="stats" id="stats" style="display: none;">
                    <div class="stat-box">
                        <div class="stat-value" id="displayedConnections">0</div>
                        <div class="stat-label">Displayed (Graph)</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="totalConnections">0</div>
                        <div class="stat-label">Total (All Views)</div>
                    </div>
                </div>
                
                <div class="company-filter-section" id="companyFilterSection" style="display: none;">
                    <h3>üè¢ Filter by Company</h3>
                    <div class="filter-actions">
                        <button class="filter-btn select-all" onclick="selectAllCompanies()">Select All</button>
                        <button class="filter-btn clear-all" onclick="clearAllCompanies()">Clear All</button>
                    </div>
                    <div style="margin: 10px 0; padding: 10px; background: white; border-radius: 5px;">
                        <label style="display: flex; align-items: center; cursor: pointer; font-size: 13px;">
                            <input type="checkbox" id="clusterToggle" onchange="toggleClustering(this.checked)" style="margin-right: 8px;">
                            <span>üîó Enable Company Clustering</span>
                        </label>
                    </div>
                    <div class="company-list" id="companyList"></div>
                </div>
                
                <div class="filter-section">
                    <h2>Filters</h2>
                    <div class="filter-group">
                        <label>Company</label>
                        <input type="text" id="filterCompany" class="filter-input" placeholder="Filter by company..." onkeyup="applyFilters()">
                    </div>
                    <div class="filter-group">
                        <label>Position</label>
                        <input type="text" id="filterPosition" class="filter-input" placeholder="Filter by position..." onkeyup="applyFilters()">
                    </div>
                    <div class="filter-group">
                        <label>Connected Date</label>
                        <input type="text" id="filterDate" class="filter-input" placeholder="Filter by date..." onkeyup="applyFilters()">
                    </div>
                </div>
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <div id="loadingText">Click "Load CSV" to import your LinkedIn connections</div>
        </div>

        <div class="notification" id="notification"></div>
    </div>

    <script>
        let allData = [];
        let filteredData = [];
        let simulation;
        let svg, g, link, node, text;
        let selectedNode = null;
        let isLoading = false;
        let selectedCompanies = new Set();
        let companyColors = {};
        let clusteringEnabled = false;
        let currentViz = 'graph';
        const currentYear = new Date().getFullYear();
        let currentCalendarYear = currentYear;
        let currentTimelineYear = currentYear; // Default to current year for faster loading
        let currentGraphYear = currentYear; // Default to current year for faster loading
        let currentBubbleYear = currentYear; // Default to current year for faster loading
        let minCompanySize = 5; // Minimum number of connections per company to display
        let showMembers = true; // Show individual connections (default: true)
        let expandedCompanies = new Set(); // Track which companies are expanded when showMembers is false
        
        // Initialize
        document.getElementById('csvFile').addEventListener('change', handleFileSelect);
        
        function switchViz(vizType) {
            currentViz = vizType;

            // Update tabs
            document.querySelectorAll('.viz-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');

            // Update panels
            document.querySelectorAll('.viz-panel').forEach(panel => panel.classList.remove('active'));

            if (vizType === 'graph') {
                document.getElementById('graphPanel').classList.add('active');
                applyYearFilterAndRebuild();
            } else if (vizType === 'timeline') {
                document.getElementById('timelinePanel').classList.add('active');
                buildTimelineChart(filteredData, currentTimelineYear);
            } else if (vizType === 'bubble') {
                document.getElementById('bubblePanel').classList.add('active');
                buildBubbleChart(filteredData, currentBubbleYear);
            } else if (vizType === 'calendar') {
                document.getElementById('calendarPanel').classList.add('active');
                buildCalendarChart(filteredData, currentCalendarYear);
            } else if (vizType === 'career') {
                document.getElementById('careerPanel').classList.add('active');
                // Career timeline is loaded separately with its own CSV
            }
        }
        
        function toggleClustering(enabled) {
            clusteringEnabled = enabled;
            console.log('Clustering toggled:', enabled);

            // Rebuild graph with clustering
            if (filteredData.length > 0) {
                applyYearFilterAndRebuild();
            }
            
            if (enabled) {
                showNotification('Company clustering enabled! Nodes grouped by company.', 'success');
            } else {
                showNotification('Company clustering disabled.', 'success');
            }
        }
        
        function buildCompanyFilter() {
            // Count connections per company
            const companyCounts = {};
            allData.forEach(conn => {
                const company = conn.company || 'Unknown';
                companyCounts[company] = (companyCounts[company] || 0) + 1;
            });
            
            // Sort companies by count (descending)
            const sortedCompanies = Object.entries(companyCounts)
                .sort((a, b) => b[1] - a[1]);
            
            // Generate colors for each company
            const colors = [
                '#0077b5', '#28a745', '#dc3545', '#ffc107', '#17a2b8', 
                '#6f42c1', '#fd7e14', '#20c997', '#e83e8c', '#6c757d',
                '#007bff', '#28a745', '#ffc107', '#dc3545', '#17a2b8'
            ];
            
            sortedCompanies.forEach(([company], index) => {
                companyColors[company] = colors[index % colors.length];
                selectedCompanies.add(company); // All selected by default
            });
            
            // Build HTML
            const companyListHtml = sortedCompanies.map(([company, count]) => {
                const initial = company.charAt(0).toUpperCase();
                const color = companyColors[company];
                
                return `
                    <div class="company-item" onclick="toggleCompany('${escapeHtml(company)}')">
                        <input type="checkbox" 
                               id="company_${escapeHtml(company)}" 
                               checked 
                               onchange="handleCompanyCheckbox('${escapeHtml(company)}', event)">
                        <div class="company-icon" style="background: ${color};">
                            ${initial}
                        </div>
                        <div class="company-name">${escapeHtml(company)}</div>
                        <div class="company-count">${count}</div>
                    </div>
                `;
            }).join('');
            
            document.getElementById('companyList').innerHTML = companyListHtml;
            document.getElementById('companyFilterSection').style.display = 'block';
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function toggleCompany(company) {
            const checkbox = document.getElementById(`company_${company}`);
            if (checkbox) {
                checkbox.checked = !checkbox.checked;
                handleCompanyCheckbox(company, checkbox.checked);
            }
        }
        
        function handleCompanyCheckbox(company, eventOrChecked) {
            // Handle both real events and boolean values
            let isChecked;
            if (typeof eventOrChecked === 'boolean') {
                isChecked = eventOrChecked;
            } else {
                if (eventOrChecked.stopPropagation) {
                    eventOrChecked.stopPropagation();
                }
                isChecked = eventOrChecked.target.checked;
            }
            
            if (isChecked) {
                selectedCompanies.add(company);
            } else {
                selectedCompanies.delete(company);
            }
            
            applyCompanyFilter();
        }
        
        function selectAllCompanies() {
            selectedCompanies.clear();
            Object.keys(companyColors).forEach(company => {
                selectedCompanies.add(company);
                const checkbox = document.getElementById(`company_${company}`);
                if (checkbox) checkbox.checked = true;
            });
            applyCompanyFilter();
        }
        
        function clearAllCompanies() {
            selectedCompanies.clear();
            Object.keys(companyColors).forEach(company => {
                const checkbox = document.getElementById(`company_${company}`);
                if (checkbox) checkbox.checked = false;
            });
            applyCompanyFilter();
        }
        
        function applyCompanyFilter() {
            console.log('=== APPLYING COMPANY FILTER ===');
            console.log('Selected companies:', Array.from(selectedCompanies));

            // Filter data based on selected companies
            filteredData = allData.filter(conn => {
                const company = conn.company || 'Unknown';
                return selectedCompanies.has(company);
            });

            console.log(`Filtered to ${filteredData.length} connections`);

            // Rebuild all visualizations with year filters applied
            applyYearFilterAndRebuild();
            buildTimelineChart(filteredData, currentTimelineYear);
            buildBubbleChart(filteredData, currentBubbleYear);

            showNotification(`Showing ${filteredData.length} connections from ${selectedCompanies.size} companies`, 'success');
        }
        
        function loadCSV() {
            document.getElementById('csvFile').click();
        }
        
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                showLoading(true);
                const reader = new FileReader();
                reader.onload = function(e) {
                    parseCSV(e.target.result);
                };
                reader.readAsText(file);
            }
        }
        
        function parseCSV(csvText) {
            Papa.parse(csvText, {
                header: true,
                skipEmptyLines: true,
                dynamicTyping: false,
                transformHeader: function(header) {
                    // Clean up headers - remove BOM and special characters
                    return header.trim().replace(/^\uFEFF/, '');
                },
                complete: function(results) {
                    console.log('Parsed CSV data:', results);
                    console.log('Total rows:', results.data.length);
                    console.log('Headers:', results.meta.fields);
                    console.log('Sample rows:', results.data.slice(0, 3));
                    
                    // Filter out empty rows and map data
                    const filtered = results.data.filter(row => {
                        const firstName = (row['First Name'] || '').trim();
                        return firstName && firstName !== 'Notes:' && firstName.length > 0;
                    });
                    
                    console.log('Filtered rows:', filtered.length);
                    
                    allData = filtered.map((row, index) => {
                        // Clean up special unicode characters from names
                        const firstName = (row['First Name'] || '').trim()
                            .replace(/[\u202a\u202c\u200f\u200e]/g, ''); // Remove direction marks
                        const lastName = (row['Last Name'] || '').trim()
                            .replace(/[\u202a\u202c\u200f\u200e]/g, '');
                        
                        return {
                            id: index,
                            firstName: firstName,
                            lastName: lastName,
                            fullName: `${firstName} ${lastName}`.trim(),
                            company: (row['Company'] || 'Unknown').trim(),
                            position: (row['Position'] || 'Unknown').trim(),
                            email: (row['Email Address'] || '').trim(),
                            url: (row['URL'] || '').trim(),
                            connectedOn: (row['Connected On'] || '').trim()
                        };
                    });
                    
                    console.log('Final data count:', allData.length);
                    console.log('Sample processed data:', allData.slice(0, 3));
                    
                    if (allData.length === 0) {
                        showLoading(false);
                        showNotification('No connections found in CSV. Please check the file format.', 'error');
                        console.error('Available columns:', results.meta.fields);
                        return;
                    }
                    
                    filteredData = [...allData];

                    console.log(`Loaded ${filteredData.length} total connections`);

                    try {
                        // Build company filter list
                        buildCompanyFilter();

                        // Update year display labels
                        document.getElementById('graphYear').textContent = currentGraphYear;
                        document.getElementById('timelineYear').textContent = currentTimelineYear;
                        document.getElementById('bubbleYear').textContent = currentBubbleYear;

                        // Build all visualizations with current year by default
                        applyYearFilterAndRebuild();
                        buildTimelineChart(filteredData, currentTimelineYear);
                        buildBubbleChart(filteredData, currentBubbleYear);

                        showNotification(`Loaded ${allData.length} connections. Showing ${currentYear} by default.`, 'success');
                        updateStats();
                    } catch (error) {
                        console.error('Error building visualizations:', error);
                        showNotification('Error building visualizations: ' + error.message, 'error');
                    } finally {
                        // Always hide loading indicator
                        showLoading(false);
                    }
                },
                error: function(error) {
                    showLoading(false);
                    showNotification('Error parsing CSV: ' + error.message, 'error');
                    console.error('Parse error:', error);
                }
            });
        }
        
        function buildGraph(data) {
            console.log(`=== BUILD GRAPH CALLED ===`);
            console.log(`Building force-directed tree with ${data.length} connections`);
            
            const width = document.getElementById('graph').clientWidth;
            const height = document.getElementById('graph').clientHeight;
            
            // Clear existing graph
            d3.select('#graph').selectAll('*').remove();
            
            // Setup SVG
            svg = d3.select('#graph')
                .attr('width', width)
                .attr('height', height);
            
            // Add zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });
            
            svg.call(zoom);
            
            g = svg.append('g');
            
            // Build force-directed tree
            buildForceDirectedTree(data, width, height);
        }
        
        function buildForceDirectedTree(data, width, height) {
            // Group connections by company
            const companiesMap = new Map();
            data.forEach(d => {
                const company = d.company || 'Unknown';
                if (!companiesMap.has(company)) {
                    companiesMap.set(company, []);
                }
                companiesMap.get(company).push(d);
            });

            // Create hierarchical structure: You -> Companies -> People (or just You -> Companies if showMembers is false)
            const root = {
                id: 'central',
                name: 'You',
                type: 'central',
                children: Array.from(companiesMap.entries()).map(([companyName, employees]) => {
                    // Show members if: global showMembers is true OR this specific company is expanded
                    const shouldShowMembers = showMembers || expandedCompanies.has(companyName);

                    return {
                        id: `company_${companyName}`,
                        name: companyName,
                        type: 'company',
                        company: companyName,
                        employeeCount: employees.length, // Store count for tooltip even when not showing members
                        isExpanded: expandedCompanies.has(companyName), // Track expansion state
                        children: shouldShowMembers ? employees.map(d => ({
                            id: d.id,
                            name: d.fullName,
                            type: 'person',
                            data: d,
                            company: companyName
                        })) : [] // Empty children array when not showing members
                    };
                })
            };

            // Convert to hierarchy
            const hierarchy = d3.hierarchy(root);
            const links = hierarchy.links();
            const nodes = hierarchy.descendants();

            // Calculate radius scale for company nodes based on employee count
            const companySizes = nodes.filter(d => d.depth === 1).map(d => {
                // Use employeeCount when members are hidden, otherwise use children length
                return showMembers ? (d.children ? d.children.length : 0) : (d.data.employeeCount || 0);
            });
            const maxCompanySize = Math.max(...companySizes);
            const minCompanySizeValue = Math.min(...companySizes);

            // Scale for company node radius (10 to 30 based on employee count)
            const radiusScale = d3.scaleLinear()
                .domain([minCompanySizeValue, maxCompanySize])
                .range([10, 30]);

            // Create force simulation for tree layout with 3 levels
            simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links)
                    .id(d => d.id)
                    .distance(d => {
                        // Longer distances for more spread
                        return d.source.depth === 0 ? 180 : 80;
                    })
                    .strength(0.3))  // Reduced from 0.7 to 0.3 for looser connections
                .force('charge', d3.forceManyBody().strength(d => {
                    // Stronger repulsion for all nodes to spread them apart
                    if (d.depth === 0) return -1000;  // You - strong repulsion
                    if (d.depth === 1) return -800;   // Companies - strong repulsion
                    return -100;                       // People - moderate repulsion
                }))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => {
                    // Dynamic collision radius based on node size
                    if (d.depth === 0) return 30;
                    if (d.depth === 1) {
                        const employeeCount = showMembers ? (d.children ? d.children.length : 0) : (d.data.employeeCount || 0);
                        return radiusScale(employeeCount) + 15;  // Add padding
                    }
                    return 15;
                }))
                .force('radial', d3.forceRadial(d => {
                    // Increased radii for more spread
                    if (d.depth === 0) return 0;
                    if (d.depth === 1) return 280;  // Companies further out
                    return 450;                      // People even further out
                }, width / 2, height / 2).strength(0.4));  // Reduced from 0.5 to 0.4
            
            // Create links
            link = g.append('g')
                .selectAll('line')
                .data(links)
                .join('line')
                .attr('stroke', '#999')
                .attr('stroke-opacity', 0.4)
                .attr('stroke-width', 1.5);
            
            // Create nodes with different sizes for each level
            node = g.append('g')
                .selectAll('circle')
                .data(nodes)
                .join('circle')
                .attr('r', d => {
                    if (d.depth === 0) return 25;      // You (center) - largest
                    if (d.depth === 1) {
                        // Company nodes - size based on employee count
                        const employeeCount = showMembers ? (d.children ? d.children.length : 0) : (d.data.employeeCount || 0);
                        return radiusScale(employeeCount);
                    }
                    return 6;                           // Person nodes - smallest
                })
                .attr('fill', d => {
                    if (d.depth === 0) return '#0077b5';  // You - LinkedIn blue
                    if (d.depth === 1) {
                        // Company nodes - use company color
                        const company = d.data.company || 'Unknown';
                        return companyColors[company] || '#28a745';
                    }
                    // Person nodes - lighter version of company color
                    const company = d.data?.company || 'Unknown';
                    const color = companyColors[company] || '#28a745';
                    // Lighten the color for person nodes
                    return d3.color(color).brighter(0.5);
                })
                .attr('stroke', d => {
                    if (d.depth === 0) return '#fff';
                    if (d.depth === 1) {
                        // Show expanded companies with gold border when members are hidden
                        return (!showMembers && d.data.isExpanded) ? '#ffc107' : '#fff';
                    }
                    return '#ddd';
                })
                .attr('stroke-width', d => {
                    if (d.depth === 1) {
                        // Thicker border for expanded companies
                        return (!showMembers && d.data.isExpanded) ? 5 : 3;
                    }
                    return 2;
                })
                .attr('opacity', d => d.depth === 2 ? 0.8 : 1)
                .style('cursor', 'pointer')
                .call(drag(simulation))
                .on('click', (event, d) => {
                    event.stopPropagation();  // Prevent event bubbling

                    if (d.depth === 1) {
                        // Company node clicked
                        if (!showMembers) {
                            // If members are globally hidden, toggle expansion for this company
                            const companyName = d.data.company;
                            if (expandedCompanies.has(companyName)) {
                                expandedCompanies.delete(companyName);
                                showNotification(`Collapsed ${companyName}`, 'success');
                            } else {
                                expandedCompanies.add(companyName);
                                showNotification(`Expanded ${companyName} - showing ${d.data.employeeCount} connections`, 'success');
                            }
                            applyYearFilterAndRebuild();
                        } else {
                            // If members are shown, just toggle highlight
                            handleCompanyHighlight(d);
                        }
                    } else if (d.depth === 2) {
                        // Person node clicked
                        handleNodeClick({
                            id: d.data.id,
                            name: d.data.name,
                            type: d.data.type,
                            data: d.data.data
                        });
                    } else if (d.depth === 0) {
                        // "You" node clicked - reset highlight
                        resetHighlight();
                    }
                })
                .on('mouseover', (event, d) => {
                    const tooltipData = {
                        name: d.data.name
                    };
                    if (d.depth === 1) {
                        // Show company name and count (use employeeCount when members are hidden)
                        const count = showMembers ? (d.children ? d.children.length : 0) : (d.data.employeeCount || 0);
                        tooltipData.name = `${d.data.name} (${count} connections)`;
                    }
                    showTooltip(event, tooltipData);
                })
                .on('mouseout', hideTooltip);

            // Create labels with different sizes
            text = g.append('g')
                .selectAll('text')
                .data(nodes)
                .join('text')
                .text(d => {
                    const name = d.data.name;
                    if (d.depth === 1) {
                        // Show company name with count (use employeeCount when members are hidden)
                        const count = showMembers ? (d.children ? d.children.length : 0) : (d.data.employeeCount || 0);
                        return `${name} (${count})`;
                    }
                    return name.length > 15 ? name.substring(0, 15) + '...' : name;
                })
                .attr('font-size', d => {
                    if (d.depth === 0) return 16;  // You - largest text
                    if (d.depth === 1) return 11;  // Company - medium text
                    return 8;                       // Person - smallest text
                })
                .attr('font-weight', d => d.depth <= 1 ? 'bold' : 'normal')
                .attr('dx', d => d.depth === 0 ? 0 : (d.depth === 1 ? 18 : 10))
                .attr('dy', d => d.depth === 0 ? -30 : 4)
                .attr('text-anchor', d => d.depth === 0 ? 'middle' : 'start')
                .attr('fill', '#fff')
                .style('pointer-events', 'none');
            
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                text
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });

            // Add click handler to SVG background to reset highlight
            svg.on('click', () => {
                resetHighlight();
            });
        }

        // Track currently highlighted company
        let highlightedCompany = null;

        function handleCompanyHighlight(companyNode) {
            const companyId = companyNode.data.id;

            // Toggle: if clicking the same company, reset
            if (highlightedCompany === companyId) {
                resetHighlight();
                return;
            }

            highlightedCompany = companyId;
            const companyName = companyNode.data.company;

            // Get IDs of all employees in this company
            const employeeIds = new Set();
            if (companyNode.children) {
                companyNode.children.forEach(child => {
                    employeeIds.add(child.data.id);
                });
            }

            // Dim all nodes except: You, this company, and its employees
            node.transition()
                .duration(300)
                .attr('opacity', d => {
                    if (d.depth === 0) return 1;  // You - always visible
                    if (d.depth === 1) {
                        return d.data.id === companyId ? 1 : 0.1;  // Highlight company, dim others
                    }
                    // Person nodes - only show if they belong to this company
                    return employeeIds.has(d.data.id) ? 0.8 : 0.05;
                });

            // Dim all text labels except for highlighted company and its employees
            text.transition()
                .duration(300)
                .attr('opacity', d => {
                    if (d.depth === 0) return 1;  // You - always visible
                    if (d.depth === 1) {
                        return d.data.id === companyId ? 1 : 0.1;
                    }
                    return employeeIds.has(d.data.id) ? 1 : 0.05;
                });

            // Dim links except those connected to highlighted company
            link.transition()
                .duration(300)
                .attr('stroke-opacity', d => {
                    // Highlight links from You to this company
                    if (d.source.depth === 0 && d.target.data.id === companyId) return 0.6;
                    // Highlight links from this company to its employees
                    if (d.source.data.id === companyId) return 0.6;
                    return 0.05;
                });

            // Highlight the same company in timeline chart
            highlightCompanyInTimeline(companyName);
        }

        function resetHighlight() {
            highlightedCompany = null;

            // Restore all nodes to original opacity
            node.transition()
                .duration(300)
                .attr('opacity', d => d.depth === 2 ? 0.8 : 1);

            // Restore all text labels
            text.transition()
                .duration(300)
                .attr('opacity', 1);

            // Restore all links
            link.transition()
                .duration(300)
                .attr('stroke-opacity', 0.4);

            // Reset timeline highlight
            resetTimelineHighlight();
        }

        // Timeline highlight functions
        function highlightCompanyInTimeline(companyName) {
            // Check if timeline bar groups exist (for stacked bar chart)
            const timelineGroups = d3.select('#timelineChart').selectAll('g g');
            if (timelineGroups.empty()) return;

            // Fade all bar groups and make only selected company visible
            timelineGroups.selectAll('rect').transition()
                .duration(300)
                .attr('opacity', function(d) {
                    const parentData = d3.select(this.parentNode).datum();
                    return parentData.key === companyName ? 0.9 : 0.1;
                });
        }

        function resetTimelineHighlight() {
            // Check if timeline bar groups exist
            const timelineGroups = d3.select('#timelineChart').selectAll('g g');
            if (timelineGroups.empty()) return;

            // Restore all bars to original opacity
            timelineGroups.selectAll('rect').transition()
                .duration(300)
                .attr('opacity', 0.7);
        }

        function buildTimelineChart(data, year = null) {
            console.log('Building timeline chart with', data.length, 'connections', year ? `for year ${year}` : '(all years)');

            // Filter by year if specified
            const filteredByYear = year ? data.filter(d => {
                const date = d3.timeParse('%d %b %Y')(d.connectedOn);
                return date && date.getFullYear() === year;
            }) : data;

            console.log('After year filter:', filteredByYear.length, 'connections');

            const svgElement = document.getElementById('timelineChart');
            const container = svgElement.parentElement;
            const width = container.clientWidth;
            const height = Math.max(container.clientHeight - 80, 400);
            const margin = {top: 40, right: 120, bottom: 80, left: 60};
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;

            // Clear existing
            d3.select('#timelineChart').selectAll('*').remove();

            // Parse dates and group by month and company
            const parseDate = d3.timeParse('%d %b %Y');
            const dataByDate = new Map();

            let parsedCount = 0;
            let skippedNoDate = 0;
            let skippedParseError = 0;

            filteredByYear.forEach(d => {
                if (!d.connectedOn) {
                    skippedNoDate++;
                    return;
                }
                const date = parseDate(d.connectedOn);
                if (!date) {
                    skippedParseError++;
                    if (skippedParseError <= 3) {
                        console.log('Failed to parse date:', d.connectedOn);
                    }
                    return;
                }

                parsedCount++;
                const monthKey = d3.timeMonth.floor(date);
                const company = d.company || 'Unknown';

                // Find existing month by comparing timestamps
                let existingMonth = null;
                for (const [key, value] of dataByDate.entries()) {
                    if (key.getTime() === monthKey.getTime()) {
                        existingMonth = key;
                        break;
                    }
                }

                if (!existingMonth) {
                    dataByDate.set(monthKey, new Map());
                    existingMonth = monthKey;
                }

                const monthData = dataByDate.get(existingMonth);
                monthData.set(company, (monthData.get(company) || 0) + 1);
            });

            console.log('Parsed dates count:', dataByDate.size);
            console.log('Successfully parsed:', parsedCount, 'Skipped (no date):', skippedNoDate, 'Skipped (parse error):', skippedParseError);

            // Get all months in range
            const allDates = Array.from(dataByDate.keys()).sort((a, b) => a - b);
            if (allDates.length === 0) {
                d3.select('#timelineChart').append('text')
                    .attr('x', width / 2)
                    .attr('y', height / 2)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#fff')
                    .text('No date information available');
                return;
            }

            const minDate = allDates[0];
            const maxDate = allDates[allDates.length - 1];

            console.log('Date range:', minDate, 'to', maxDate);

            // Create all months between min and max
            const allMonths = d3.timeMonths(minDate, d3.timeMonth.offset(maxDate, 1));

            // Get all unique companies from the actual parsed date data
            // This ensures we only use companies that actually have connection dates
            const companiesWithDates = Array.from(new Set(
                Array.from(dataByDate.values()).flatMap(monthData => Array.from(monthData.keys()))
            ));

            // Use companies from the data that have dates, filtered by selectedCompanies if applicable
            const companies = selectedCompanies.size > 0
                ? companiesWithDates.filter(c => selectedCompanies.has(c))
                : companiesWithDates;

            console.log('Total months:', allMonths.length);
            console.log('Selected companies size:', selectedCompanies.size);
            console.log('Companies for timeline:', companies);
            
            // Build complete dataset with all months
            const stackData = allMonths.map(date => {
                const obj = { date };
                // Find the matching month in dataByDate by comparing time values
                let monthData = null;
                for (const [key, value] of dataByDate.entries()) {
                    if (key.getTime() === date.getTime()) {
                        monthData = value;
                        break;
                    }
                }
                if (!monthData) monthData = new Map();

                companies.forEach(company => {
                    obj[company] = monthData.get(company) || 0;
                });
                return obj;
            });

            // Debug: Check if we have any non-zero values
            const sampleWithData = stackData.find(d => {
                return companies.some(company => d[company] > 0);
            });
            console.log('Sample month with data:', sampleWithData);
            console.log('Companies in dataByDate:', Array.from(new Set(Array.from(dataByDate.values()).flatMap(m => Array.from(m.keys())))));
            
            // Create stack
            const stack = d3.stack()
                .keys(companies)
                .order(d3.stackOrderNone)
                .offset(d3.stackOffsetNone);

            const series = stack(stackData);

            console.log('Stack data sample:', stackData.slice(0, 3));
            console.log('Series:', series.length, 'companies');
            const maxValue = d3.max(series, d => d3.max(d, d => d[1]));
            console.log('Max stack value:', maxValue);

            // Create scales
            // Use scaleBand for bars instead of scaleTime
            const x = d3.scaleBand()
                .domain(stackData.map(d => d.date))
                .range([0, innerWidth])
                .padding(0.1);

            const y = d3.scaleLinear()
                .domain([0, maxValue || 10])
                .nice()
                .range([innerHeight, 0]);
            
            // Create SVG
            const svg = d3.select('#timelineChart')
                .attr('width', width)
                .attr('height', height);
            
            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Clip path
            g.append('defs').append('clipPath')
                .attr('id', 'clip-timeline')
                .append('rect')
                .attr('width', innerWidth)
                .attr('height', innerHeight);

            const chartArea = g.append('g')
                .attr('clip-path', 'url(#clip-timeline)');

            // Draw stacked bars
            const barGroups = chartArea.selectAll('g')
                .data(series)
                .join('g')
                .attr('fill', d => companyColors[d.key] || '#999');

            const bars = barGroups.selectAll('rect')
                .data(d => d)
                .join('rect')
                .attr('x', d => x(d.data.date))
                .attr('y', d => y(d[1]))
                .attr('height', d => y(d[0]) - y(d[1]))
                .attr('width', x.bandwidth())
                .attr('opacity', 0.7)
                .style('cursor', 'pointer')
                .on('mouseover', function(event, d) {
                    // Show tooltip with company and count
                    const companyKey = d3.select(this.parentNode).datum().key;
                    const count = d[1] - d[0];
                    if (count > 0) {
                        d3.select(this).attr('opacity', 0.9);
                    }
                })
                .on('mouseout', function(event, d) {
                    d3.select(this).attr('opacity', 0.7);
                });

            console.log('Bar groups created:', barGroups.size());
            console.log('Total bars created:', bars.size());

            // Debug: Check a sample bar's attributes
            const sampleBar = bars.nodes()[0];
            if (sampleBar) {
                console.log('Sample bar attributes:', {
                    x: sampleBar.getAttribute('x'),
                    y: sampleBar.getAttribute('y'),
                    width: sampleBar.getAttribute('width'),
                    height: sampleBar.getAttribute('height')
                });
            }
            
            // Add grid lines (skip for bar chart to reduce clutter)
            // Grid doesn't work well with band scale, so we'll only show y-axis grid
            
            const yAxisGrid = g.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(y)
                    .ticks(5)
                    .tickSize(-innerWidth)
                    .tickFormat(''));
            
            yAxisGrid.selectAll('line')
                .attr('stroke', '#444')
                .attr('stroke-opacity', 0.3);
            
            // Add axes
            const xAxis = g.append('g')
                .attr('class', 'x-axis')
                .attr('transform', `translate(0,${innerHeight})`);
            
            const yAxis = g.append('g')
                .attr('class', 'y-axis');
            
            updateAxes();
            
            // Tooltip
            const tooltip = d3.select('body').append('div')
                .attr('class', 'timeline-tooltip')
                .style('position', 'absolute')
                .style('background', 'rgba(0, 0, 0, 0.9)')
                .style('color', 'white')
                .style('padding', '10px')
                .style('border-radius', '5px')
                .style('font-size', '12px')
                .style('pointer-events', 'none')
                .style('opacity', 0)
                .style('z-index', 10000);
            
            // Define zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([1, 20])
                .translateExtent([[0, 0], [innerWidth, innerHeight]])
                .filter((event) => {
                    if (event.type === 'wheel') {
                        event.preventDefault();
                        return true;
                    }
                    return !event.ctrlKey && !event.button;
                })
                .on('zoom', zoomed);

            // Hover overlay for tooltips and zoom
            const overlay = g.append('rect')
                .attr('width', innerWidth)
                .attr('height', innerHeight)
                .attr('fill', 'none')
                .style('pointer-events', 'all')
                .call(zoom)
                .on('mousemove.tooltip', handleMouseMove)
                .on('mouseout.tooltip', handleMouseOut);

            function handleMouseMove(event) {
                const [mouseX] = d3.pointer(event);

                // Find which bar we're hovering over using band scale
                const eachBand = x.step();
                const index = Math.floor(mouseX / eachBand);
                const dataPoint = stackData[index];
                
                if (dataPoint && dataPoint.date) {
                    // Build tooltip content
                    const monthYear = d3.timeFormat('%B %Y')(dataPoint.date);
                    let tooltipContent = `<strong>${monthYear}</strong><br/>`;

                    companies.forEach(company => {
                        const count = dataPoint[company] || 0;
                        if (count > 0) {
                            const color = companyColors[company] || '#999';
                            tooltipContent += `<div style="margin-top: 5px;">
                                <span style="display: inline-block; width: 10px; height: 10px; background: ${color}; margin-right: 5px;"></span>
                                ${company}: <strong>${count}</strong>
                            </div>`;
                        }
                    });

                    tooltip
                        .html(tooltipContent)
                        .style('left', (event.pageX + 15) + 'px')
                        .style('top', (event.pageY - 15) + 'px')
                        .style('opacity', 1);
                } else {
                    handleMouseOut();
                }
            }

            function handleMouseOut() {
                tooltip.style('opacity', 0);
            }

            function zoomed(event) {
                // For band scale, we manually apply the transform
                const transform = event.transform;

                // Update bars with transform
                barGroups.selectAll('rect')
                    .attr('x', d => transform.applyX(x(d.data.date)))
                    .attr('width', x.bandwidth() * transform.k);

                // Create axis scale by manually applying transform to band positions
                const transformedScale = (date) => transform.applyX(x(date));
                transformedScale.bandwidth = () => x.bandwidth() * transform.k;

                // Calculate visible range
                const [x0, x1] = [
                    transform.invertX(0),
                    transform.invertX(innerWidth)
                ];

                // Find visible data based on pixel positions
                const visibleData = stackData.filter(d => {
                    const pos = x(d.date) + x.bandwidth() / 2;
                    return pos >= x0 && pos <= x1;
                });

                // Determine tick frequency based on visible range
                let tickValues;
                const visibleMonths = visibleData.length;

                if (visibleMonths > 120) {
                    tickValues = visibleData.filter((d, i) => i % 12 === 0).map(d => d.date);
                } else if (visibleMonths > 60) {
                    tickValues = visibleData.filter((d, i) => i % 6 === 0).map(d => d.date);
                } else if (visibleMonths > 24) {
                    tickValues = visibleData.filter((d, i) => i % 3 === 0).map(d => d.date);
                } else if (visibleMonths > 12) {
                    tickValues = visibleData.filter((d, i) => i % 2 === 0).map(d => d.date);
                } else {
                    tickValues = visibleData.map(d => d.date);
                }

                // Update axis with transformed positions
                xAxis.call(g => {
                    g.selectAll('.tick').remove();

                    tickValues.forEach(date => {
                        const tick = g.append('g')
                            .attr('class', 'tick')
                            .attr('transform', `translate(${transformedScale(date) + transformedScale.bandwidth() / 2}, 0)`);

                        tick.append('line')
                            .attr('stroke', '#999')
                            .attr('y2', 6);

                        tick.append('text')
                            .attr('fill', '#fff')
                            .attr('y', 9)
                            .attr('dy', '0.71em')
                            .attr('transform', 'rotate(-45)')
                            .style('text-anchor', 'end')
                            .text(d3.timeFormat('%b %Y')(date));
                    });
                });
            }

            function updateAxes() {
                // For bar chart, show limited ticks based on data range
                const totalMonths = stackData.length;

                // Determine tick frequency based on total months
                let tickValues;
                if (totalMonths > 120) {
                    // Show every 12th month (yearly)
                    tickValues = stackData.filter((d, i) => i % 12 === 0).map(d => d.date);
                } else if (totalMonths > 60) {
                    // Show every 6th month
                    tickValues = stackData.filter((d, i) => i % 6 === 0).map(d => d.date);
                } else if (totalMonths > 24) {
                    // Show every 3rd month (quarterly)
                    tickValues = stackData.filter((d, i) => i % 3 === 0).map(d => d.date);
                } else {
                    // Show all months
                    tickValues = stackData.map(d => d.date);
                }

                xAxis.call(d3.axisBottom(x)
                    .tickValues(tickValues)
                    .tickFormat(d3.timeFormat('%b %Y')));

                xAxis.selectAll('text')
                    .attr('fill', '#fff')
                    .attr('transform', 'rotate(-45)')
                    .style('text-anchor', 'end');

                yAxis.call(d3.axisLeft(y).ticks(5));

                xAxis.selectAll('.domain, .tick line').attr('stroke', '#999');
                yAxis.selectAll('text').attr('fill', '#fff');
                yAxis.selectAll('.domain, .tick line').attr('stroke', '#999');
            }

            // Add title
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', 20)
                .attr('text-anchor', 'middle')
                .attr('font-size', 18)
                .attr('font-weight', 'bold')
                .attr('fill', '#fff')
                .text(year ? `Connections in ${year} by Company` : 'Connections Over Time by Company');

            // Add zoom instructions
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height - 5)
                .attr('text-anchor', 'middle')
                .attr('font-size', 11)
                .attr('fill', '#aaa')
                .text('Scroll to zoom ‚Ä¢ Double-click to reset');

            // Add legend
            const legend = svg.append('g')
                .attr('transform', `translate(${width - margin.right + 10}, ${margin.top})`);
            
            companies.forEach((company, i) => {
                const legendRow = legend.append('g')
                    .attr('transform', `translate(0, ${i * 20})`);
                
                legendRow.append('rect')
                    .attr('width', 15)
                    .attr('height', 15)
                    .attr('fill', companyColors[company]);
                
                legendRow.append('text')
                    .attr('x', 20)
                    .attr('y', 12)
                    .attr('font-size', 11)
                    .attr('fill', '#fff')
                    .text(company.length > 15 ? company.substring(0, 15) + '...' : company);
            });
        }
        
        function buildBubbleChart(data, year = null) {
            console.log('Building bubble chart with', data.length, 'connections', year ? `for year ${year}` : '(all years)');

            // Filter by year if specified
            const filteredByYear = year ? data.filter(d => {
                const date = new Date(d.connectedOn);
                return date && date.getFullYear() === year;
            }) : data;

            console.log('After year filter:', filteredByYear.length, 'connections');

            const width = document.getElementById('bubbleChart').clientWidth;
            const height = document.getElementById('bubbleChart').clientHeight;
            const margin = {top: 60, right: 20, bottom: 20, left: 20};

            // Clear existing
            d3.select('#bubbleChart').selectAll('*').remove();

            // Group by company
            const companyData = d3.rollup(
                filteredByYear,
                v => v.length,
                d => d.company || 'Unknown'
            );
            
            // Create hierarchy
            const root = d3.hierarchy({ children: Array.from(companyData, ([name, value]) => ({ name, value })) })
                .sum(d => d.value)
                .sort((a, b) => b.value - a.value);
            
            // Create pack layout
            const pack = d3.pack()
                .size([width - margin.left - margin.right, height - margin.top - margin.bottom])
                .padding(5);
            
            pack(root);
            
            // Create SVG
            const svg = d3.select('#bubbleChart')
                .attr('width', width)
                .attr('height', height);
            
            // Add zoom
            const zoom = d3.zoom()
                .scaleExtent([0.5, 8])
                .on('zoom', zoomed);
            
            svg.call(zoom);
            
            const g = svg.append('g')
                .attr('transform', `translate(${margin.left}, ${margin.top})`);
            
            // Tooltip
            const tooltip = d3.select('body').append('div')
                .attr('class', 'bubble-tooltip')
                .style('position', 'absolute')
                .style('background', 'rgba(0, 0, 0, 0.9)')
                .style('color', 'white')
                .style('padding', '10px')
                .style('border-radius', '5px')
                .style('font-size', '12px')
                .style('pointer-events', 'none')
                .style('opacity', 0)
                .style('z-index', 10000);
            
            // Create bubbles
            const bubbles = g.selectAll('g')
                .data(root.children)
                .join('g')
                .attr('transform', d => `translate(${d.x},${d.y})`)
                .style('cursor', 'pointer');
            
            bubbles.append('circle')
                .attr('r', d => Math.max(0, d.r || 0))
                .attr('fill', d => companyColors[d.data.name] || '#28a745')
                .attr('opacity', 0.7)
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                .on('mouseover', function(event, d) {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('opacity', 1)
                        .attr('stroke-width', 4);
                    
                    tooltip
                        .html(`
                            <strong>${d.data.name}</strong><br/>
                            <span style="color: ${companyColors[d.data.name]};">‚óè</span> ${d.value} connections<br/>
                            <span style="font-size: 10px; color: #aaa;">Click to filter</span>
                        `)
                        .style('left', (event.pageX + 15) + 'px')
                        .style('top', (event.pageY - 15) + 'px')
                        .style('opacity', 1);
                })
                .on('mouseout', function() {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('opacity', 0.7)
                        .attr('stroke-width', 2);
                    
                    tooltip.style('opacity', 0);
                })
                .on('click', function(event, d) {
                    // Toggle company selection
                    const company = d.data.name;
                    const checkbox = document.getElementById(`company_${company}`);
                    if (checkbox) {
                        checkbox.checked = !checkbox.checked;
                        handleCompanyCheckbox(company, checkbox.checked);
                    }
                });
            
            // Add text labels
            bubbles.each(function(d) {
                const bubble = d3.select(this);
                const textSize = Math.min(d.r / 3, 16);
                
                // Company name
                bubble.append('text')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '-0.3em')
                    .attr('font-size', textSize)
                    .attr('fill', '#fff')
                    .attr('font-weight', 'bold')
                    .style('pointer-events', 'none')
                    .text(d.data.name.length > 12 ? d.data.name.substring(0, 12) + '...' : d.data.name);
                
                // Connection count (only if bubble is large enough)
                if (d.r > 30) {
                    bubble.append('text')
                        .attr('text-anchor', 'middle')
                        .attr('dy', '1em')
                        .attr('font-size', Math.min(d.r / 4, 14))
                        .attr('fill', '#fff')
                        .style('pointer-events', 'none')
                        .text(d.value + ' connections');
                }
            });
            
            function zoomed(event) {
                g.attr('transform', `translate(${margin.left + event.transform.x}, ${margin.top + event.transform.y}) scale(${event.transform.k})`);
            }
            
            // Add title
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', 30)
                .attr('text-anchor', 'middle')
                .attr('font-size', 18)
                .attr('font-weight', 'bold')
                .attr('fill', '#fff')
                .text(year ? `Connections by Company in ${year}` : 'Connections by Company (Zoom with scroll)');
            
            // Add instructions
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', 50)
                .attr('text-anchor', 'middle')
                .attr('font-size', 12)
                .attr('fill', '#aaa')
                .text('Scroll to zoom ‚Ä¢ Click bubble to filter');
        }

        // Graph navigation functions
        function changeGraphYear(delta) {
            if (currentGraphYear === null) {
                const years = Array.from(new Set(filteredData.map(d => new Date(d.connectedOn).getFullYear()))).sort();
                currentGraphYear = delta > 0 ? years[0] : years[years.length - 1];
            } else {
                currentGraphYear += delta;
            }
            document.getElementById('graphYear').textContent = currentGraphYear;
            applyYearFilterAndRebuild();
        }

        function resetGraphYear() {
            currentGraphYear = null;
            document.getElementById('graphYear').textContent = 'All Years';
            applyYearFilterAndRebuild();
        }

        // Timeline navigation functions
        function changeTimelineYear(delta) {
            if (currentTimelineYear === null) {
                const years = Array.from(new Set(filteredData.map(d => new Date(d.connectedOn).getFullYear()))).sort();
                currentTimelineYear = delta > 0 ? years[0] : years[years.length - 1];
            } else {
                currentTimelineYear += delta;
            }
            document.getElementById('timelineYear').textContent = currentTimelineYear;
            buildTimelineChart(filteredData, currentTimelineYear);
        }

        function resetTimelineYear() {
            currentTimelineYear = null;
            document.getElementById('timelineYear').textContent = 'All Years';
            buildTimelineChart(filteredData, null);
        }

        // Bubble chart navigation functions
        function changeBubbleYear(delta) {
            if (currentBubbleYear === null) {
                const years = Array.from(new Set(filteredData.map(d => new Date(d.connectedOn).getFullYear()))).sort();
                currentBubbleYear = delta > 0 ? years[0] : years[years.length - 1];
            } else {
                currentBubbleYear += delta;
            }
            document.getElementById('bubbleYear').textContent = currentBubbleYear;
            buildBubbleChart(filteredData, currentBubbleYear);
        }

        function resetBubbleYear() {
            currentBubbleYear = null;
            document.getElementById('bubbleYear').textContent = 'All Years';
            buildBubbleChart(filteredData, null);
        }

        // Apply year filter to graph and rebuild
        function applyYearFilterAndRebuild() {
            let yearFilteredData = filteredData;

            if (currentGraphYear !== null) {
                yearFilteredData = filteredData.filter(d => {
                    const date = new Date(d.connectedOn);
                    return date.getFullYear() === currentGraphYear;
                });
            }

            // Apply company size filter
            const companyCounts = new Map();
            yearFilteredData.forEach(d => {
                const company = d.company || 'Unknown';
                companyCounts.set(company, (companyCounts.get(company) || 0) + 1);
            });

            const companySizeFilteredData = yearFilteredData.filter(d => {
                const company = d.company || 'Unknown';
                return companyCounts.get(company) >= minCompanySize;
            });

            console.log(`Year filter: ${yearFilteredData.length} connections, Company size filter (>=${minCompanySize}): ${companySizeFilteredData.length} connections`);

            // Display the filtered data
            buildGraph(companySizeFilteredData);
            updateStats();
        }

        // Update minimum company size filter
        function updateMinCompanySize(value) {
            minCompanySize = parseInt(value);
            applyYearFilterAndRebuild();
        }

        // Toggle show/hide individual members
        function toggleShowMembers(checked) {
            showMembers = checked;
            if (checked) {
                // Clear expanded companies when showing all members
                expandedCompanies.clear();
                showNotification('Showing all individual connections', 'success');
            } else {
                showNotification('Showing companies only - click a company to expand it', 'success');
            }
            applyYearFilterAndRebuild();
        }

        // Calendar navigation functions
        function changeCalendarYear(delta) {
            currentCalendarYear += delta;
            document.getElementById('calendarYear').textContent = currentCalendarYear;
            buildCalendarChart(filteredData, currentCalendarYear);
        }

        function buildCalendarChart(data, year) {
            console.log('Building calendar chart for year:', year);

            // Get the parent container instead of the SVG element
            const svgElement = document.getElementById('calendarChart');
            const container = svgElement.parentElement; // Get the .graph-container div

            // Log container dimensions for debugging
            console.log('Calendar container info:', {
                containerClass: container.className,
                clientWidth: container.clientWidth,
                clientHeight: container.clientHeight,
                offsetWidth: container.offsetWidth,
                offsetHeight: container.offsetHeight,
                computedStyle: window.getComputedStyle(container).width
            });

            const width = container.clientWidth || 1200;
            const height = Math.max(container.clientHeight - 80, 600); // Ensure minimum height

            console.log('Using width:', width, 'height:', height);

            // Clear existing
            d3.select('#calendarChart').selectAll('*').remove();

            // Filter data for the selected year
            const yearData = data.filter(d => {
                const date = new Date(d.connectedOn);
                return date.getFullYear() === year;
            });

            // Aggregate connections by date
            const dateMap = d3.rollup(
                yearData,
                v => v.length,
                d => d3.timeDay.floor(new Date(d.connectedOn)).toISOString().split('T')[0]
            );

            // Convert to array for max calculation
            const counts = Array.from(dateMap.values());
            const maxCount = counts.length > 0 ? d3.max(counts) : 1;

            console.log(`Year ${year}: ${yearData.length} connections, max per day: ${maxCount}`);

            // Create color scale
            const colorScale = d3.scaleSequential()
                .domain([0, maxCount])
                .interpolator(d3.interpolateBlues);

            // Calendar dimensions - sized to fit viewport
            const cellSize = 10; // Slightly smaller cell size
            const weekGap = 1;
            const weekWidth = cellSize + weekGap;
            const monthLabelHeight = 20;
            const dayLabelWidth = 12;

            // Calculate dimensions for horizontal month layout (6 months per row)
            const monthWidth = (weekWidth * 5) + dayLabelWidth + 12; // ~5 weeks per month + labels
            const monthHeight = (weekWidth * 7) + monthLabelHeight + 15; // 7 days + label

            // Calculate total calendar size
            const totalCalendarWidth = monthWidth * 6 + 80; // 6 months per row + margins
            const totalCalendarHeight = monthHeight * 2 + 120; // 2 rows + margins

            const svg = d3.select('#calendarChart')
                .attr('width', width)
                .attr('height', height);

            // Add scrollable group
            const mainGroup = svg.append('g');

            // Title
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', 30)
                .attr('text-anchor', 'middle')
                .attr('font-size', 22)
                .attr('font-weight', 'bold')
                .attr('fill', '#fff')
                .text(`Connection Activity Calendar - ${year}`);

            // Create a group for each month - horizontal layout (months side by side)
            const months = d3.timeMonths(new Date(year, 0, 1), new Date(year, 11, 31));

            const monthGroups = mainGroup.append('g')
                .attr('transform', `translate(40, 70)`)
                .selectAll('g')
                .data(months)
                .join('g')
                .attr('transform', (d, i) => {
                    // Arrange months horizontally, 6 per row
                    const col = i % 6;
                    const row = Math.floor(i / 6);
                    return `translate(${col * monthWidth}, ${row * monthHeight})`;
                });

            // Month labels (at the top of each month)
            monthGroups.append('text')
                .attr('x', monthWidth / 2)
                .attr('y', 0)
                .attr('text-anchor', 'middle')
                .attr('font-size', 12)
                .attr('font-weight', 'bold')
                .attr('fill', '#fff')
                .text(d => d3.timeFormat('%b')(d)); // Abbreviated month name

            // Tooltip
            const tooltip = d3.select('body').append('div')
                .attr('class', 'calendar-tooltip')
                .style('position', 'absolute')
                .style('background', 'rgba(0, 0, 0, 0.9)')
                .style('color', 'white')
                .style('padding', '8px 12px')
                .style('border-radius', '5px')
                .style('font-size', '12px')
                .style('pointer-events', 'none')
                .style('opacity', 0)
                .style('z-index', 10000);

            // Create cells for each month - grid layout
            monthGroups.each(function(monthDate) {
                const group = d3.select(this);
                const monthStart = d3.timeMonth.floor(monthDate);
                const monthEnd = d3.timeMonth.offset(monthStart, 1);
                const days = d3.timeDays(monthStart, monthEnd);

                // Add day cells - positioned in weekly grid
                const cells = group.selectAll('rect')
                    .data(days)
                    .join('rect')
                    .attr('width', cellSize)
                    .attr('height', cellSize)
                    .attr('x', d => {
                        // Week number within this month
                        const weekInMonth = d3.timeWeek.count(monthStart, d);
                        return dayLabelWidth + (weekInMonth * weekWidth);
                    })
                    .attr('y', d => monthLabelHeight + (d.getDay() * weekWidth))
                    .attr('fill', d => {
                        const dateStr = d.toISOString().split('T')[0];
                        const count = dateMap.get(dateStr) || 0;
                        return count > 0 ? colorScale(count) : '#2a2a2a';
                    })
                    .attr('stroke', '#444')
                    .attr('stroke-width', 0.5)
                    .attr('rx', 1)
                    .style('cursor', 'pointer')
                    .on('mouseover', function(event, d) {
                        const dateStr = d.toISOString().split('T')[0];
                        const count = dateMap.get(dateStr) || 0;

                        d3.select(this)
                            .attr('stroke', '#fff')
                            .attr('stroke-width', 2);

                        tooltip
                            .html(`
                                <strong>${d3.timeFormat('%B %d, %Y')(d)}</strong><br/>
                                ${count} connection${count !== 1 ? 's' : ''}
                            `)
                            .style('left', (event.pageX + 15) + 'px')
                            .style('top', (event.pageY - 15) + 'px')
                            .style('opacity', 1);
                    })
                    .on('mouseout', function() {
                        d3.select(this)
                            .attr('stroke', '#444')
                            .attr('stroke-width', 0.5);

                        tooltip.style('opacity', 0);
                    });

                // Add day of week labels (on the left side)
                if (monthDate.getMonth() === 0 || monthDate.getMonth() === 6) {
                    const weekdays = ['S', 'M', 'T', 'W', 'T', 'F', 'S'];
                    group.selectAll('text.weekday')
                        .data(weekdays)
                        .join('text')
                        .attr('class', 'weekday')
                        .attr('x', dayLabelWidth - 3)
                        .attr('y', (d, i) => monthLabelHeight + (i * weekWidth) + cellSize / 2)
                        .attr('dy', '0.3em')
                        .attr('text-anchor', 'end')
                        .attr('font-size', 8)
                        .attr('fill', '#999')
                        .text(d => d);
                }
            });

            // Legend
            const legendWidth = Math.min(300, width - 100);
            const legendHeight = 20;
            const legendX = Math.max(60, width - legendWidth - 40);
            const legendY = height - 50;

            const legendScale = d3.scaleLinear()
                .domain([0, maxCount])
                .range([0, legendWidth]);

            const legend = svg.append('g')
                .attr('transform', `translate(${legendX}, ${legendY})`);

            // Legend gradient
            const defs = svg.append('defs');
            const gradient = defs.append('linearGradient')
                .attr('id', 'legend-gradient');

            gradient.selectAll('stop')
                .data(d3.range(0, 1.1, 0.1))
                .join('stop')
                .attr('offset', d => d)
                .attr('stop-color', d => colorScale(d * maxCount));

            legend.append('rect')
                .attr('width', legendWidth)
                .attr('height', legendHeight)
                .style('fill', 'url(#legend-gradient)')
                .attr('stroke', '#fff')
                .attr('stroke-width', 1);

            // Legend axis
            const legendAxis = d3.axisBottom(legendScale)
                .ticks(5)
                .tickFormat(d => Math.round(d));

            legend.append('g')
                .attr('transform', `translate(0, ${legendHeight})`)
                .call(legendAxis)
                .call(g => g.select('.domain').attr('stroke', '#fff'))
                .call(g => g.selectAll('.tick line').attr('stroke', '#fff'))
                .call(g => g.selectAll('.tick text').attr('fill', '#fff').attr('font-size', 10));

            legend.append('text')
                .attr('x', -10)
                .attr('y', legendHeight / 2)
                .attr('dy', '0.3em')
                .attr('text-anchor', 'end')
                .attr('font-size', 11)
                .attr('fill', '#fff')
                .text('Connections per day:');

            // Summary stats
            svg.append('text')
                .attr('x', 40)
                .attr('y', height - 20)
                .attr('font-size', 12)
                .attr('fill', '#aaa')
                .text(`Total connections in ${year}: ${yearData.length} ‚Ä¢ Peak day: ${maxCount} connections`);

            // Add zoom and pan
            const zoom = d3.zoom()
                .scaleExtent([0.5, 6])
                .on('zoom', (event) => {
                    mainGroup.attr('transform', event.transform);
                });

            svg.call(zoom);

            // Set initial zoom to fit content perfectly in viewport
            const scaleToFit = Math.min(
                (width - 100) / totalCalendarWidth,
                (height - 140) / totalCalendarHeight
            ) * 0.98;

            // Center the calendar horizontally
            const translateX = (width - (totalCalendarWidth * scaleToFit)) / 2;
            svg.call(zoom.transform, d3.zoomIdentity
                .translate(translateX, 0)
                .scale(scaleToFit));

            // Instructions
            svg.append('text')
                .attr('x', width - 40)
                .attr('y', height - 20)
                .attr('text-anchor', 'end')
                .attr('font-size', 11)
                .attr('fill', '#aaa')
                .text('Scroll to zoom ‚Ä¢ Drag to pan');
        }
        
        function drag(simulation) {
            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }
            
            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }
            
            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }
            
            return d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended);
        }
        
        function handleNodeClick(nodeData) {
            selectedNode = nodeData;
            
            // Update node colors
            node.attr('fill', d => {
                if (d.id === nodeData.id) return '#ffc107';
                if (d.type === 'central') return '#0077b5';
                const company = d.data?.company || 'Unknown';
                return companyColors[company] || '#28a745';
            });
            
            // Show sidebar
            document.getElementById('sidebar').classList.add('active');
            
            if (nodeData.type === 'central') {
                document.getElementById('nodeInfo').innerHTML = `
                    <div class="node-info">
                        <div class="info-item">
                            <div class="info-label">Name</div>
                            <div class="info-value">You (Central Node)</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Total Connections</div>
                            <div class="info-value">${allData.length}</div>
                        </div>
                    </div>
                `;
            } else {
                const data = nodeData.data;
                document.getElementById('nodeInfo').innerHTML = `
                    <div class="node-info">
                        <div class="info-item">
                            <div class="info-label">Name</div>
                            <div class="info-value">${data.fullName}</div>
                        </div>
                        ${data.company ? `
                        <div class="info-item">
                            <div class="info-label">Company</div>
                            <div class="info-value">${data.company}</div>
                        </div>
                        ` : ''}
                        ${data.position ? `
                        <div class="info-item">
                            <div class="info-label">Position</div>
                            <div class="info-value">${data.position}</div>
                        </div>
                        ` : ''}
                        ${data.email ? `
                        <div class="info-item">
                            <div class="info-label">Email</div>
                            <div class="info-value">${data.email}</div>
                        </div>
                        ` : ''}
                        ${data.url ? `
                        <div class="info-item">
                            <div class="info-label">LinkedIn Profile</div>
                            <div class="info-value">
                                <a href="${data.url}" target="_blank" style="color: #0077b5; text-decoration: none;">
                                    View Profile
                                </a>
                            </div>
                        </div>
                        ` : ''}
                        ${data.connectedOn ? `
                        <div class="info-item">
                            <div class="info-label">Connected On</div>
                            <div class="info-value">${data.connectedOn}</div>
                        </div>
                        ` : ''}
                    </div>
                `;
            }
        }
        
        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY - 10) + 'px';
            tooltip.textContent = d.name;
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }
        
        function handleSearch() {
            const query = document.getElementById('searchBox').value.toLowerCase().trim();
            applyFilters();
        }
        
        function applyFilters() {
            console.log('=== APPLY FILTERS CALLED ===');
            const searchQuery = document.getElementById('searchBox').value.toLowerCase().trim();
            const companyFilter = document.getElementById('filterCompany').value.toLowerCase().trim();
            const positionFilter = document.getElementById('filterPosition').value.toLowerCase().trim();
            const dateFilter = document.getElementById('filterDate').value.toLowerCase().trim();
            
            console.log('Filters:', { searchQuery, companyFilter, positionFilter, dateFilter });
            
            filteredData = allData.filter(d => {
                const matchSearch = !searchQuery || 
                    d.fullName.toLowerCase().includes(searchQuery) ||
                    d.company.toLowerCase().includes(searchQuery) ||
                    d.position.toLowerCase().includes(searchQuery) ||
                    d.email.toLowerCase().includes(searchQuery);
                
                const matchCompany = !companyFilter || d.company.toLowerCase().includes(companyFilter);
                const matchPosition = !positionFilter || d.position.toLowerCase().includes(positionFilter);
                const matchDate = !dateFilter || d.connectedOn.toLowerCase().includes(dateFilter);
                
                return matchSearch && matchCompany && matchPosition && matchDate;
            });
            
            if (allData.length > 0) {
                console.log(`After filter: ${filteredData.length} connections`);
                applyYearFilterAndRebuild();
                buildTimelineChart(filteredData, currentTimelineYear);
                buildBubbleChart(filteredData, currentBubbleYear);
            }
        }
        
        function resetView() {
            document.getElementById('searchBox').value = '';
            document.getElementById('filterCompany').value = '';
            document.getElementById('filterPosition').value = '';
            document.getElementById('filterDate').value = '';
            filteredData = [...allData];
            if (allData.length > 0) {
                applyYearFilterAndRebuild();
                buildTimelineChart(filteredData, currentTimelineYear);
                buildBubbleChart(filteredData, currentBubbleYear);
            }
            selectedNode = null;
        }
        
        function toggleSidebar() {
            document.getElementById('sidebar').classList.toggle('active');
        }
        
        function exportGraph() {
            const exportData = {
                connections: allData,
                stats: {
                    total: allData.length,
                    filtered: filteredData.length
                },
                exportDate: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'linkedin_connections_export.json';
            a.click();
            URL.revokeObjectURL(url);
            
            showNotification('Graph exported successfully!', 'success');
        }
        
        function updateStats() {
            document.getElementById('stats').style.display = 'flex';
            document.getElementById('totalConnections').textContent = allData.length;
            document.getElementById('displayedConnections').textContent = filteredData.length;

            // Update header count
            const countEl = document.getElementById('connectionCount');
            countEl.style.display = 'inline-block';
            countEl.textContent = `${filteredData.length} connections`;
        }
        
        function showLoading(show) {
            const loading = document.getElementById('loading');
            if (show) {
                loading.classList.remove('hidden');
                document.getElementById('loadingText').textContent = 'Loading connections...';
            } else {
                loading.classList.add('hidden');
            }
        }
        
        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type} show`;
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }
        
        // Career Timeline Functions
        let careerChart = null;

        function loadCareerCSV() {
            document.getElementById('careerCsvFile').click();
        }

        document.getElementById('careerCsvFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                complete: function(results) {
                    console.log('Career CSV loaded:', results.data);
                    buildCareerTimeline(results.data);
                    document.getElementById('careerStatus').textContent = `${results.data.length} positions loaded`;
                    document.getElementById('careerStatus').style.display = 'inline-block';
                },
                error: function(error) {
                    console.error('Error parsing career CSV:', error);
                    showNotification('Error loading career CSV file', 'error');
                }
            });
        });

        function buildCareerTimeline(data) {
            // Clear previous chart
            if (careerChart) {
                careerChart.dispose();
            }

            // Count connections per company from LinkedIn data (if loaded)
            const companyCounts = {};
            if (allData && allData.length > 0) {
                allData.forEach(conn => {
                    const company = conn.company || 'Unknown';
                    companyCounts[company] = (companyCounts[company] || 0) + 1;
                });
            }

            // Create timeline chart
            careerChart = anychart.timeline();

            // Set chart title
            careerChart.title('Professional Career Timeline');

            // Prepare data for moment series (the info boxes)
            const titleDescData = [];
            const locationData = [];
            const connectionsData = [];

            // Create a range series for each position
            data.forEach((position, index) => {
                const startDate = parseCareerDate(position['Started On']);
                const endDate = position['Finished On'] ? parseCareerDate(position['Finished On']) : new Date();
                const midDate = new Date((startDate.getTime() + endDate.getTime()) / 2);
                const color = getCareerColor(position['Company Name']);
                const title = position['Title'];
                const company = position['Company Name'];
                const description = position['Description'] || '';
                const location = position['Location'] || '';
                const connectionCount = companyCounts[company] || 0;

                // Add data for moment series (info boxes)
                // Box 1: Title + Description
                titleDescData.push({
                    x: midDate.getTime(),
                    title: title,
                    company: company,
                    description: description,
                    color: color
                });

                // Box 2: Location
                if (location) {
                    locationData.push({
                        x: midDate.getTime(),
                        location: location,
                        company: company,
                        color: color
                    });
                }

                // Box 3: Connections
                if (connectionCount > 0) {
                    connectionsData.push({
                        x: midDate.getTime(),
                        count: connectionCount,
                        company: company,
                        color: color
                    });
                }

                // Create range series with the position data (the timeline bar)
                var series = careerChart.range([
                    [company, startDate.getTime(), endDate.getTime()]
                ]);

                // Set the bar color
                series.fill(color);
                series.stroke(color);

                // Configure bar height
                series.height(25);

                // Enable labels on the bar to show company name
                series.labels().enabled(true);
                series.labels().fontColor('white');
                series.labels().fontSize(12);
                series.labels().fontWeight('bold');

                // Simplified tooltip
                series.tooltip().useHtml(true);
                series.tooltip().titleFormat('<h5>{%x}</h5>');
                series.tooltip().format(function() {
                    const startDate = new Date(this.start);
                    const endDate = new Date(this.end);
                    const monthsDiff = Math.round((endDate - startDate) / (1000 * 60 * 60 * 24 * 30));
                    const years = Math.floor(monthsDiff / 12);
                    const months = monthsDiff % 12;
                    const duration = years > 0 ? `${years}y ${months}m` : `${months}m`;

                    return `<div style="padding: 10px;">
                        <div style="margin-bottom: 3px;">${formatCareerDate(startDate)} - ${formatCareerDate(endDate)}</div>
                        <div style="margin-bottom: 5px; color: #666;">Duration: ${duration}</div>
                    </div>`;
                });
            });

            // Create moment series for info boxes

            // 1. Title + Description boxes (topmost)
            if (titleDescData.length > 0) {
                var titleDescSeries = careerChart.moment(titleDescData.map(d => ({
                    x: d.x,
                    value: 'title-desc'
                })));

                titleDescSeries.labels().enabled(true);
                titleDescSeries.labels().useHtml(true);
                titleDescSeries.labels().padding(5);
                titleDescSeries.labels().format(function() {
                    const data = titleDescData[this.index];
                    const shortDesc = data.description.length > 100 ? data.description.substring(0, 100) + '...' : data.description;
                    return `<div style="padding: 8px; background: white; border-radius: 5px; border-left: 4px solid ${data.color}; box-shadow: 0 2px 4px rgba(0,0,0,0.1); max-width: 300px;">
                        <div style="font-weight: bold; color: #0077b5; margin-bottom: 3px;">${data.title}</div>
                        ${data.description ? `<div style="font-size: 11px; color: #555;">${shortDesc}</div>` : ''}
                    </div>`;
                });
                titleDescSeries.tooltip().enabled(false);
            }

            // 2. Location boxes (middle)
            if (locationData.length > 0) {
                var locationSeries = careerChart.moment(locationData.map(d => ({
                    x: d.x,
                    value: 'location'
                })));

                locationSeries.labels().enabled(true);
                locationSeries.labels().useHtml(true);
                locationSeries.labels().padding(5);
                locationSeries.labels().format(function() {
                    const data = locationData[this.index];
                    return `<div style="padding: 6px 10px; background: white; border-radius: 5px; border-left: 4px solid ${data.color}; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <div style="font-size: 11px; color: #666;">üìç ${data.location}</div>
                    </div>`;
                });
                locationSeries.tooltip().enabled(false);
            }

            // 3. Connections boxes (lowest, just above the bar)
            if (connectionsData.length > 0) {
                var connectionsSeries = careerChart.moment(connectionsData.map(d => ({
                    x: d.x,
                    value: 'connections'
                })));

                connectionsSeries.labels().enabled(true);
                connectionsSeries.labels().useHtml(true);
                connectionsSeries.labels().padding(5);
                connectionsSeries.labels().format(function() {
                    const data = connectionsData[this.index];
                    return `<div style="padding: 6px 10px; background: white; border-radius: 5px; border-left: 4px solid ${data.color}; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <div style="font-size: 11px; color: #28a745; font-weight: bold;">üë• ${data.count} connections</div>
                    </div>`;
                });
                connectionsSeries.tooltip().enabled(false);
            }

            // Configure axis
            var axis = careerChart.axis();
            axis.height(25);

            // Enable scroller
            careerChart.scroller().enabled(true);

            // Set container and draw
            careerChart.container('careerTimeline');
            careerChart.background().fill({
                keys: ['#667eea', '#764ba2'],
                angle: 135
            });
            careerChart.draw();

            showNotification('Career timeline loaded successfully!', 'success');
        }

        function parseCareerDate(dateStr) {
            if (!dateStr) return new Date();

            // Handle format like "Jul 2022" or "Feb 2016"
            const parts = dateStr.trim().split(' ');
            if (parts.length === 2) {
                const months = {
                    'Jan': 0, 'Feb': 1, 'Mar': 2, 'Apr': 3, 'May': 4, 'Jun': 5,
                    'Jul': 6, 'Aug': 7, 'Sep': 8, 'Oct': 9, 'Nov': 10, 'Dec': 11
                };
                const month = months[parts[0]];
                const year = parseInt(parts[1]);
                return new Date(year, month, 1);
            }

            return new Date(dateStr);
        }

        function formatCareerDate(date) {
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                          'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            return `${months[date.getMonth()]} ${date.getFullYear()}`;
        }

        function getCareerColor(companyName) {
            // Define color palette for career timeline
            const colors = [
                '#0077b5', '#28a745', '#dc3545', '#ffc107', '#17a2b8',
                '#6f42c1', '#fd7e14', '#20c997', '#e83e8c', '#6c757d',
                '#007bff', '#28a745', '#ffc107', '#dc3545', '#17a2b8'
            ];

            // Check if company already has a color assigned from LinkedIn connections
            if (companyColors[companyName]) {
                return companyColors[companyName];
            }

            // Otherwise assign a new color based on current companies count
            const colorIndex = Object.keys(companyColors).length % colors.length;
            companyColors[companyName] = colors[colorIndex];
            return companyColors[companyName];
        }

        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            console.log('=== WINDOW RESIZE TRIGGERED ===');
            if (allData.length > 0) {
                // Debounce resize to avoid multiple calls
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    console.log('Rebuilding visualizations after resize');
                    if (currentViz === 'graph') {
                        applyYearFilterAndRebuild();
                    } else if (currentViz === 'timeline') {
                        buildTimelineChart(filteredData, currentTimelineYear);
                    } else if (currentViz === 'bubble') {
                        buildBubbleChart(filteredData, currentBubbleYear);
                    } else if (currentViz === 'calendar') {
                        buildCalendarChart(filteredData, currentCalendarYear);
                    } else if (currentViz === 'career' && careerChart) {
                        careerChart.draw();
                    }
                }, 250);
            }
        });
    </script>
</body>
</html>